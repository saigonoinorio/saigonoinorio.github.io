{"meta":{"title":"saigonoinori","subtitle":null,"description":"kanate","author":"me","url":"https://saigonoinorio.github.io"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"about/index.html","permalink":"https://saigonoinorio.github.io/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"client/index.html","permalink":"https://saigonoinorio.github.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"bangumi/index.html","permalink":"https://saigonoinorio.github.io/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"comment/index.html","permalink":"https://saigonoinorio.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"donate/index.html","permalink":"https://saigonoinorio.github.io/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"lab/index.html","permalink":"https://saigonoinorio.github.io/lab/index.html","excerpt":"","text":"sakura主题 balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"links/index.html","permalink":"https://saigonoinorio.github.io/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"music/index.html","permalink":"https://saigonoinorio.github.io/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"rss/index.html","permalink":"https://saigonoinorio.github.io/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"tags/index.html","permalink":"https://saigonoinorio.github.io/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://saigonoinorio.github.io/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"video/index.html","permalink":"https://saigonoinorio.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2022-11-14T13:16:02.124Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"https://saigonoinorio.github.io/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"前言 LCT 虽然是 101010 级算法，但是非常实用，所以 zlxFTH 决定将它加入科技树。 LCT 全称 Link Cut Tree，用来解决动态树问题，所谓动态树问题，就是支持加入一条边，删除一条边，同时维护树上的一些信息，因此，LCT 实际上维护的是一个动态树森林。 实现 LCT 采用实链剖分，即我们钦定哪个儿子是实儿子，其他儿子是虚儿子，类似于树链剖分，链接实儿子的边叫做实边，链接虚儿子的边叫做虚边，实边构成的链叫做实链，通过虚边将实链相连。 LCT 使用一棵 Splay 来维护一条实链，这棵 Splay 的中序遍历的节点序列即为原树中实链从上往下的节点序列，特别地，这棵 Splay 的根也有父亲，它指向的是原树中实链上深度最小的点的父亲（根节点则为 000），为了保持 Splay 的性质，根节点的父子关系为认父不认子，即这棵 Splay 的根有父亲，但是那个父亲没有这个儿子。 例题：【P3690】【模板】动态树（Link Cut Tree） 给定 nnn 个点以及每个点的权值，要你处理接下来的 mmm 个操作。 0 x y 代表询问从 xxx 到 yyy 的路径上的点的权值的 xor\\text{xor}xor 和。保证 xxx 到 yyy 是联通的。 1 x y 代表连接 xxx 到 yyy，若 xxx 到 yyy 已经联通则无需连接。 2 x y 代表删除边 (x,y)(x,y)(x,y)，不保证边 (x,y)(x,y)(x,y) 存在。 3 x y 代表将点 xxx 上的权值变成 yyy。 1≤n≤1051 \\leq n \\leq 10^51≤n≤105，1≤m≤3×1051 \\leq m \\leq 3 \\times 10^51≤m≤3×105，1≤ai≤1091 \\leq a_i \\leq 10^91≤ai​≤109 变量定义 int ch[N][2],fa[N],sum[N],val[N],tag[N]; 分别表示两个儿子，父亲，整棵子树的 ⊕\\oplus⊕ 和，节点的值，是否有翻转标记。 sum 和 val 都可以根据题目来魔改。 基础函数 inline int ls(int o){return ch[o][0];} inline int rs(int o){return ch[o][1];} inline int dir(int o){return ch[fa[o]][1]==o;} inline void pushUp(int o){sum[o]=sum[ch[o][0]]^sum[ch[o][1]]^val[o];} inline void pushDown(int o){ if(tag[o]){ swap(ch[o][0],ch[o][1]); if(ls(o))tag[ls(o)]^=1; if(rs(o))tag[rs(o)]^=1; tag[o]=0; } } inline int isRoot(int o){return !(ch[fa[o]][0]==o||ch[fa[o]][1]==o);} ls，rs 主要是为了好写而定义的函数，分别表示节点 ooo 的左右儿子。 dir 是判断当前节点是父亲的左儿子还是右儿子的函数。 pushUp 是上传标记，更新信息。 pushDown 是下发表示，下放翻转标记。 isRoot 用于判断当前节点是否是这棵 Splay 的根节点，只需要判断他的父亲有没有他这个儿子即可。 pushUp 和 pushDown 函数都可以根据题目来魔改。 Splay 系列操作 inline void rot(int o){ int x=fa[o],d=dir(o); if((ch[x][d]=ch[o][d^1])!=0)fa[ch[o][d^1]]=x; if((fa[o]=fa[x]),!isRoot(x))ch[fa[x]][dir(x)]=o; pushUp(ch[o][d^1]=x),pushUp(fa[x]=o); } inline void splay(int o){ int tp=0,x=o; static int st[N]; while(!isRoot(x))st[++tp]=x,x=fa[x]; st[++tp]=x; while(tp)pushDown(st[tp--]); for(;(x=fa[o]),!isRoot(o);rot(o))if(!isRoot(x))rot(dir(o)==dir(x)?x:o); } 单次旋转和 Splay 操作（把一个点旋转到整棵 Splay 得到根节点），不同的是判断根节点的方式，以及每次 Splay 要提前依次下放标记，这里使用栈实现，避免递归，减少常数。 LCT 系列操作 inline int access(int o){ int p;for(p=0;o;p=o,o=fa[o])splay(o),ch[o][1]=p,pushUp(o); return p; } inline void makeRoot(int o){o=access(o),tag[o]^=1;} LCT 的核心，通过这两个函数，LCT 可以灵活应对各种树上操作。 acess，注意不是 assert，表示打通原树上根节点到 ooo 的路径，把他们全部变成实边，整条路径上的点原有的实边要改成虚边，依次合并每条实链即可，ppp 维护的是上一条实链的根节点，先把当前点旋转到 Splay 的根，那么它的右子树应该断掉重新改成现在的 ppp（更新实边），记得 pushUp 更新信息，处理完之后更新 ppp 和 ooo，跳到上面。 makeRoot，换根操作，把 ooo 当做新的根节点，只需要将根节点和 ooo 的路径打通之后打一个翻转标记即可（中序遍历反向）。 inline void split(int u,int v){makeRoot(u),access(v),splay(v);} inline int findRoot(int o){ access(o),splay(o),pushDown(o); while(ch[o][0])o=ch[o][0],pushDown(o); splay(o); return o; } inline void link(int u,int v){ makeRoot(u),splay(u); if(findRoot(v)==u)return; fa[u]=v; } inline void cut(int u,int v){ makeRoot(u); if(findRoot(v)==u&amp;&amp;fa[v]==u&amp;&amp;!ch[v][0]){ fa[v]=ch[u][1]=0; pushUp(u); } } split，提取出来 u,vu,vu,v 之间的路径，先把 uuu 当成根，打通 uuu 到 vvv 的路径，这里将 vvv 旋转到根便于操作。 findRoot，找到 ooo 所在树的根节点，先把 ooo 到根的路径打通，把 ooo 旋转到 Splay 树的根节点，然后递归找下去（注意下放标记），最后一定要 Splay 一下保证复杂度正确。 link，将 u,vu,vu,v 之间连边，需要先检查联通性，把 uuu 当成根之后，findRoot 判断，注意要 Splay 一下保证复杂度。 cut，将 u,vu,vu,v 之间的边删除，需要先检查 u,vu,vu,v 之间是否有边，把 uuu 当成根之后 vvv 所在树的根必须是 uuu，父亲必须是 uuu，vvv 为根的 Splay 左子树没有其他点，中序遍历相连。 致此，所有 LCT 的基础函数都实现了，可以灵活地去运用这棵 LCT 了。 先放一下例题的完整代码： // zlxFTH // time: #include&lt;bits/stdc++.h&gt; #define rep(i,alpha,iee) for(auto gs##i=(iee),i=(alpha);i&lt;=gs##i;++i) #define per(i,alpha,iee) for(auto gs##i=(iee),i=(alpha);i&gt;=gs##i;--i) #define fi first #define se second #define ep emplace #define eb emplace_back using namespace std; typedef long long ll; namespace IO{ char buf[1&lt;&lt;20],*p1,*p2; // #define gc() (p1==p2&amp;&amp;(p2=buf+fread(p1=buf,1,1&lt;&lt;20,stdin),p1==p2)?-1:*p1++) #define gc() getchar() template&lt;class T&gt; inline void read(T &amp;x){ x=0;int f=0;char c=gc(); for(;!isdigit(c);c=gc())f|=(c=='-'); for(;isdigit(c);c=gc())x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48); x=f?-x:x; } #undef gc }using namespace IO; const int N=3e5+10; namespace LCT{ int ch[N][2],fa[N],sum[N],val[N],tag[N]; inline int ls(int o){return ch[o][0];} inline int rs(int o){return ch[o][1];} inline int dir(int o){return ch[fa[o]][1]==o;} inline void pushUp(int o){sum[o]=sum[ch[o][0]]^sum[ch[o][1]]^val[o];} inline void pushDown(int o){ if(tag[o]){ swap(ch[o][0],ch[o][1]); if(ls(o))tag[ls(o)]^=1; if(rs(o))tag[rs(o)]^=1; tag[o]=0; } } inline int isRoot(int o){return !(ch[fa[o]][0]==o||ch[fa[o]][1]==o);} inline void rot(int o){ int x=fa[o],d=dir(o); if((ch[x][d]=ch[o][d^1])!=0)fa[ch[o][d^1]]=x; if((fa[o]=fa[x]),!isRoot(x))ch[fa[x]][dir(x)]=o; pushUp(ch[o][d^1]=x),pushUp(fa[x]=o); } inline void splay(int o){ int tp=0,x=o; static int st[N]; while(!isRoot(x))st[++tp]=x,x=fa[x]; st[++tp]=x; while(tp)pushDown(st[tp--]); for(;(x=fa[o]),!isRoot(o);rot(o))if(!isRoot(x))rot(dir(o)==dir(x)?x:o); } inline int access(int o){ int p;for(p=0;o;p=o,o=fa[o])splay(o),ch[o][1]=p,pushUp(o); return p; } inline void makeRoot(int o){o=access(o),tag[o]^=1;} inline void split(int u,int v){makeRoot(u),access(v),splay(v);} inline int findRoot(int o){ access(o),splay(o),pushDown(o); while(ch[o][0])o=ch[o][0],pushDown(o); splay(o); return o; } inline void link(int u,int v){ makeRoot(u),splay(u); if(findRoot(v)==u)return; fa[u]=v; } inline void cut(int u,int v){ makeRoot(u); if(findRoot(v)==u&amp;&amp;fa[v]==u&amp;&amp;!ch[v][0]){ fa[v]=ch[u][1]=0; pushUp(u); } } }using namespace LCT; int main(){ int n,T;read(n),read(T); rep(i,1,n)read(val[i]),pushUp(i); while(T--){ int op,u,v;read(op),read(u),read(v); if(op==0)split(u,v),printf(&quot;%d\\n&quot;,sum[v]); else if(op==1)link(u,v); else if(op==2)cut(u,v); else splay(u),val[u]=v,pushUp(u); } return 0; } 例题 维护链信息 主要是利用 Splay 维护链。 【P3203】【HNOI2010】弹飞绵羊 建一个虚拟点 n+1n+1n+1，每次操作相当于 cutcutcut 之后再 linklinklink，只需要维护 Splay 子树 sizsizsiz。 属于对 LCT 的基础理解。 // zlxFTH // time: 14:04 #include&lt;bits/stdc++.h&gt; #define rep(i,alpha,iee) for(auto gs##i=(iee),i=(alpha);i&lt;=gs##i;++i) #define per(i,alpha,iee) for(auto gs##i=(iee),i=(alpha);i&gt;=gs##i;--i) #define fi first #define se second #define ep emplace #define eb emplace_back using namespace std; typedef long long ll; namespace IO{ char buf[1&lt;&lt;20],*p1,*p2; // #define gc() (p1==p2&amp;&amp;(p2=buf+fread(p1=buf,1,1&lt;&lt;20,stdin),p1==p2)?-1:*p1++) #define gc() getchar() template&lt;class T&gt; inline void read(T &amp;x){ x=0;int f=0;char c=gc(); for(;!isdigit(c);c=gc())f|=(c=='-'); for(;isdigit(c);c=gc())x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48); x=f?-x:x; } #undef gc }using namespace IO; const int N=2e5+10; namespace LCT{ int ch[N][2],fa[N],siz[N],tag[N]; inline int ls(int o){return ch[o][0];} inline int rs(int o){return ch[o][1];} inline void pushUp(int o){siz[o]=siz[ls(o)]+siz[rs(o)]+1;} inline void pushDown(int o){ if(tag[o]){ if(ls(o))tag[ls(o)]^=1; if(rs(o))tag[rs(o)]^=1; swap(ch[o][0],ch[o][1]); tag[o]=0; } } inline int dir(int o){return ch[fa[o]][1]==o;} inline bool isRoot(int o){return !(ch[fa[o]][0]==o||ch[fa[o]][1]==o);} inline void rot(int o){ int x=fa[o],d=dir(o); if((ch[x][d]=ch[o][d^1])!=0)fa[ch[o][d^1]]=x; if((fa[o]=fa[x]),!isRoot(x))ch[fa[x]][dir(x)]=o; pushUp(ch[o][d^1]=x),pushUp(fa[x]=o); } inline void splay(int o){ int tp=0,x=o; static int st[N]; while(!isRoot(x))st[++tp]=x,x=fa[x]; st[++tp]=x; while(tp)pushDown(st[tp--]); for(;(x=fa[o]),!isRoot(o);rot(o))if(!isRoot(x))rot(dir(x)==dir(o)?x:o); } inline int access(int o){ int p=0;for(p=0;o;p=o,o=fa[o])splay(o),ch[o][1]=p,pushUp(o); return p; } inline void makeRoot(int o){o=access(o),tag[o]^=1;} inline void split(int u,int v){makeRoot(u),access(v),splay(v);} inline int findRoot(int o){ access(o),splay(o);pushDown(o); while(ch[o][0])o=ch[o][0],pushDown(o); splay(o); return o; } inline void link(int u,int v){ makeRoot(u),splay(u); if(findRoot(v)==u)return; fa[u]=v; } inline void cut(int u,int v){ makeRoot(u); if(findRoot(v)==u&amp;&amp;fa[v]==u&amp;&amp;!ch[v][0]){ fa[v]=ch[u][1]=0; pushUp(u); } } }using namespace LCT; int n,k[N]; int main(){ read(n); rep(i,1,n+1)pushUp(i); rep(i,1,n)read(k[i]),link(i,min(i+k[i],n+1)); int T;read(T); while(T--){ int op;read(op); if(op==1){ int u;read(u),++u; makeRoot(n+1),access(u),splay(n+1); printf(&quot;%d\\n&quot;,siz[ch[n+1][1]]); } else{ int i;read(i),++i; cut(i,min(i+k[i],n+1)); read(k[i]); link(i,min(i+k[i],n+1)); } } return 0; } 维护子树信息 【P4219】【BJOI2014】大融合 LCT 如何维护原树子树的信息？ 每一个 Splay 维护的都是一条条实链，一棵子树是由若干条实链构成的，发现我们只需要对每一个 Splay 节点记录一个 sisisi 值表示父亲指向这个节点的虚儿子的信息之和。 原来 sss 值就可以改成 Splay 上面以当前点为根节点子树内所有信息之和。 假如说我们要维护一个子树节点和： s[o]=s[ls(o)]+s[rs(o)]+si[o]+1; 当 ooo 这个点 makeroot 之后的 sss 值就是其子树的大小。 access 要对应更改： inline int access(int o){ int p=0;for(p=0;o;p=o,o=fa[o]){ splay(o); si[o]+=s[ch[o][1]]; ch[o][1]=p; si[o]-=s[p]; pushUp(o); } return p; } link 也需要，因为都改变了虚儿子的信息： inline void link(int u,int v){ makeRoot(u),splay(u); if(findRoot(v)==u)return; makeRoot(v),splay(v); fa[u]=v; si[v]+=s[u]; pushUp(v); } 这里有一个易错点，那就是 vvv 必须要 makeroot！因为 vvv 不是其子树的根的话需要修改的节点不止一个 vvv。 完整代码： // zlxFTH // time: 16:26 #include&lt;bits/stdc++.h&gt; #define rep(i,alpha,iee) for(auto gs##i=(iee),i=(alpha);i&lt;=gs##i;++i) #define per(i,alpha,iee) for(auto gs##i=(iee),i=(alpha);i&gt;=gs##i;--i) #define fi first #define se second #define ep emplace #define eb emplace_back using namespace std; typedef long long ll; namespace IO{ char buf[1&lt;&lt;20],*p1,*p2; // #define gc() (p1==p2&amp;&amp;(p2=buf+fread(p1=buf,1,1&lt;&lt;20,stdin),p1==p2)?-1:*p1++) #define gc() getchar() template&lt;class T&gt; inline void read(T &amp;x){ x=0;int f=0;char c=gc(); for(;!isdigit(c);c=gc())f|=(c=='-'); for(;isdigit(c);c=gc())x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48); x=f?-x:x; } #undef gc }using namespace IO; const int N=1e5+10; namespace LCT{ int ch[N][2],fa[N],s[N],si[N],tag[N]; inline int ls(int o){return ch[o][0];} inline int rs(int o){return ch[o][1];} inline void pushUp(int o){ s[o]=s[ls(o)]+s[rs(o)]+si[o]+1; } inline void pushDown(int o){ if(tag[o]){ swap(ch[o][0],ch[o][1]); if(ls(o))tag[ls(o)]^=1; if(rs(o))tag[rs(o)]^=1; tag[o]=0; } } inline int isRoot(int o){return !(ch[fa[o]][0]==o||ch[fa[o]][1]==o);} inline int dir(int o){return ch[fa[o]][1]==o;} inline void rot(int o){ int x=fa[o],d=dir(o); if((ch[x][d]=ch[o][d^1]))fa[ch[o][d^1]]=x; if(fa[o]=fa[x],!isRoot(x))ch[fa[x]][dir(x)]=o; pushUp(ch[o][d^1]=x),pushUp(fa[x]=o); } inline void splay(int o){ int tp=0,x=o; static int st[N]; while(!isRoot(x))st[++tp]=x,x=fa[x]; st[++tp]=x; while(tp)pushDown(st[tp--]); for(;(x=fa[o]),!isRoot(o);rot(o))if(!isRoot(x))rot(dir(x)==dir(o)?x:o); } inline int access(int o){ int p=0;for(p=0;o;p=o,o=fa[o]){ splay(o); si[o]+=s[ch[o][1]]; ch[o][1]=p; si[o]-=s[p]; pushUp(o); } return p; } inline void makeRoot(int o){o=access(o),tag[o]^=1;} inline void split(int u,int v){makeRoot(u),access(v),splay(v);} inline int findRoot(int o){ access(o),splay(o),pushDown(o); while(ch[o][0])o=ch[o][0],pushDown(o); splay(o); return o; } inline void link(int u,int v){ makeRoot(u),splay(u); if(findRoot(v)==u)return; makeRoot(v),splay(v); fa[u]=v; si[v]+=s[u]; pushUp(v); } inline void cut(int u,int v){ makeRoot(u); if(findRoot(v)==u&amp;&amp;fa[v]==u&amp;&amp;!ch[v][0]){ fa[v]=ch[u][1]=0; pushUp(u); } } }using namespace LCT; int n,T; int main(){ read(n),read(T); rep(i,1,n)pushUp(i); rep(cas,1,T){ string op;cin&gt;&gt;op; if(op==&quot;A&quot;){ int u,v;read(u),read(v); link(u,v); } else{ int u,v;read(u),read(v); cut(u,v); makeRoot(u),makeRoot(v); splay(u),splay(v); printf(&quot;%lld\\n&quot;,1ll*s[u]*s[v]); link(u,v); } } return 0; }","categories":[{"name":"技术","slug":"技术","permalink":"https://saigonoinorio.github.io/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"https://saigonoinorio.github.io/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://saigonoinorio.github.io/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://saigonoinorio.github.io/categories/技术/"}]}]}