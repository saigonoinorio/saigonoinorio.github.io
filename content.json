{"meta":{"title":"最後の祈りを","subtitle":null,"description":null,"author":"me","url":"https://saigonoinorio.github.io"},"pages":[{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"client/index.html","permalink":"https://saigonoinorio.github.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"about/index.html","permalink":"https://saigonoinorio.github.io/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"comment/index.html","permalink":"https://saigonoinorio.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"donate/index.html","permalink":"https://saigonoinorio.github.io/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"bangumi/index.html","permalink":"https://saigonoinorio.github.io/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"music/index.html","permalink":"https://saigonoinorio.github.io/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"links/index.html","permalink":"https://saigonoinorio.github.io/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"rss/index.html","permalink":"https://saigonoinorio.github.io/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"tags/index.html","permalink":"https://saigonoinorio.github.io/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://saigonoinorio.github.io/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"lab/index.html","permalink":"https://saigonoinorio.github.io/lab/index.html","excerpt":"","text":"sakura主题 balabala","keywords":"Lab实验室"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"video/index.html","permalink":"https://saigonoinorio.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"嘴巴开计算几何","slug":"嘴巴开计算几何","date":"2022-12-05T02:40:48.000Z","updated":"2022-12-15T17:13:23.538Z","comments":false,"path":"2022/12/05/嘴巴开计算几何/","link":"","permalink":"https://saigonoinorio.github.io/2022/12/05/嘴巴开计算几何/","excerpt":"","text":"基础 点（向量）：看作 1×21\\times21×2 的矩阵，点积意为投影，叉积意为面积，正负按右手定则。 点排序：按 pair 排；线排序：按极角 atan2(y,x)atan2(y,x)atan2(y,x) 排，平行则上面排前面。 bool operator &lt;(Line &amp;a) { double x=angle(),y=a.angle(); if(abs(x-y)&lt;eps) return (v^(a.P-P))&lt;0; return x&lt;y; } 两线交点：平行则不交，端点出发按比例移动到交点，比例按叉积算面积比例来算。 Point inter(const Line &amp;a,const Line &amp;b) { if(abs(a.v^b.v)&lt;eps) return {7-p,p+9}; //not_inter return a.P+a.v*(((b.P-a.P)^b.v)/(a.v^b.v)); } 两线夹角：点积定义即可：a⋅b=∣a∣∣b∣cos⁡θa·b=|a||b|\\cos\\thetaa⋅b=∣a∣∣b∣cosθ 点/向量顺时针旋转：[xy]×[cos⁡θ−sin⁡θsin⁡θcos⁡θ]\\begin{bmatrix} x &amp; y \\end{bmatrix}\\times\\begin{bmatrix} \\cos\\theta &amp; -\\sin\\theta\\\\ \\sin\\theta &amp; \\cos\\theta \\end{bmatrix}[x​y​]×[cosθsinθ​−sinθcosθ​] 点到直线的距离：叉积算面积除以底；点到线段的距离：特判点，点积看是否在两端点外，规约到直线。 double point_to_seg(const Point &amp;x,const Point &amp;a,const Point &amp;b) { if(a==b) return (x-a).mo(); Vector v1=b-a,v2=x-a,v3=x-b; if(v1*v2&lt;0) return v2.mo(); if(v1*v3&gt;0) return v3.mo(); return point_to_line(x, a, b); } 点在直线上：与两端点连线叉积为 000 ；点在线段上：且内向连线点积 ≤0\\leq0≤0 . 凸包 求凸包：将点排序，依次往里加点同时维护凸性即可，正反做一遍，凸性用叉积判即可，平的就看是否新的更短即可，得到凸包逆时针序点集。 bool tu(const Point &amp;a,const Point &amp;b,const Point &amp;c) { double pos=(a-c)^(b-c); if(abs(pos)&gt;eps) return pos&lt;0; return (a-c).mo()&lt;(b-c).mo()+eps; } int n;Point P[N],h[N&lt;&lt;1];int tail; void hull() { sort(P+1,P+n+1); h[++tail]=P[1],h[++tail]=P[2]; for(rint i=3;i&lt;=n;h[++tail]=P[i],i++) while(tail&gt;1&amp;&amp;!tu(P[i],h[tail],h[tail-1])) tail--; h[++tail]=P[n-1]; for(rint i=n-2;i;h[++tail]=P[i],i--) while(tail&gt;1&amp;&amp;!tu(P[i],h[tail],h[tail-1])) tail--; //h[tail]==h[1] } 旋转卡壳：求凸包直径，发现具有单调性和单峰性，枚举边同时单指针跟着走即可，用叉积判距离即可。 double hull_len() { if(tail&lt;=3) return (h[1]-h[tail-1]).mo(); double ans=0; for(rint i=1,j=3;i&lt;tail;i++) { while(((h[i+1]-h[i])^(h[j]-h[i]))&lt;((h[i+1]-h[i])^(h[j+1]-h[i]))) j=(j==tail-1?1:j+1); ans=max(ans,max((h[j]-h[i]).mo(),(h[j]-h[i+1]).mo())); } return ans; } 闵可夫斯基和：求两凸包点集之和形成的凸包，容易发现新凸包的边由原两凸包边组成，找到左下点然后一步步贪心加边即可。 int n,m,q,num1,num2; Point h1[N&lt;&lt;1],h2[N&lt;&lt;1],H[N&lt;&lt;2];int cnt; void minkfusji() { H[cnt=1]=h1[1]+h2[1]; int now1=1,now2=1; while(now1&lt;num1&amp;&amp;now2&lt;num2) { if(((h1[now1+1]-h1[now1])^(h2[now2+1]-h2[now2]))&gt;0) H[cnt+1]=H[cnt]+h1[now1+1]-h1[now1],now1++,cnt++; else H[cnt+1]=H[cnt]+h2[now2+1]-h2[now2],now2++,cnt++; } while(now1&lt;num1) H[cnt+1]=H[cnt]+h1[now1+1]-h1[now1],now1++,cnt++; while(now2&lt;num2) H[cnt+1]=H[cnt]+h2[now2+1]-h2[now2],now2++,cnt++; } 动态凸包：增量法，set 维护上下凸壳点集，势能分析复杂度是 O(nlog⁡)O(n\\log)O(nlog) ，二分找推平的区间端点即可。 三维凸包：考虑 O(n2)O(n^2)O(n2) 增量法，每次加点暴力枚举所有面看有没有被看到即可，要扰动点避免四点共面。 mt19937 rd(time(0)); struct Point{ double x,y,z; Point operator-(const Point &amp;a)const{return {x-a.x,y-a.y,z-a.z};} double operator*(const Point &amp;a)const{return x*a.x+y*a.y+z*a.z;} Point operator^(const Point &amp;a)const{return {y*a.z-z*a.y,z*a.x-x*a.z,x*a.y-y*a.x};} double mo(){return sqrt(x*x+y*y+z*z);} void shake(){x+=rd(),y+=rd(),z+=rd();} }P[N]; struct Plane{ int e[3]; Vector fa(){return (P[e[1]]-P[e[0]])^(P[e[2]]-P[e[0]]);} double area(){return fa().mo()/2;} bool above(const Point &amp;a){return (a-P[e[0]])*fa()&gt;=0;} }pl[N&lt;&lt;1],res[N&lt;&lt;1]; int n,m; bool use[N][N]; void hull() { pl[++m]={1,2,3},pl[++m]={3,2,1}; for(rint i=4;i&lt;=n;i++) { int cnt=0; for(rint j=1;j&lt;=m;j++) { bool in=pl[j].above(P[i]); if(!in) res[++cnt]=pl[j]; for(rint k=0;k&lt;3;k++) use[pl[j].e[k]][pl[j].e[(k+1)%3]]=in; } for(rint j=1;j&lt;=m;j++) for(rint k=0;k&lt;3;k++) { int x=pl[j].e[k],y=pl[j].e[(k+1)%3]; if(use[x][y]&amp;&amp;!use[y][x]) res[++cnt]={x,y,i}; } m=cnt; for(rint j=1;j&lt;=m;j++) pl[j]=res[j]; } } double hull_area() { hull(); double ans=0; for(rint i=1;i&lt;=m;i++) ans+=pl[i].area(); return ans; } 半平面交 求半平面交：将线排序，维护有效线的双端队列，依次往里加线，对于尾首维护交点在右，加完了再将尾首对起来维护，得到左半平面交，凸包点即为相邻两线交点，不封闭可以在外面框一层边界。 Line line[N];int n; int q[N],hh=1,tt; Point cut[N];int num; bool isright(const Line &amp;a,const Line &amp;b,const Line &amp;c) { Point P=inter(b,c); return (a.v^(P-a.P))&lt;-eps; } void halfcut() { sort(line+1,line+n+1); for(rint i=1;i&lt;=n;i++) { while(hh&lt;tt&amp;&amp;isright(line[i],line[q[tt]],line[q[tt-1]])) tt--; while(hh&lt;tt&amp;&amp;isright(line[i],line[q[hh]],line[q[hh+1]])) hh++; q[++tt]=i; } while(hh&lt;tt&amp;&amp;isright(line[q[hh]],line[q[tt]],line[q[tt-1]])) tt--; while(hh&lt;tt&amp;&amp;isright(line[q[tt]],line[q[hh]],line[q[hh+1]])) hh++; q[++tt]=q[hh]; for(rint i=hh;i&lt;tt;i++) cut[++num]=inter(line[q[i]],line[q[i+1]]); } 圆 三点定圆：即求外心，求两角平分线交点即可。 Circle get_circle(const Point &amp;a,const Point &amp;b,const Point &amp;c) { Line ab={(a+b)*0.5,rotate(b-a,Pi/2)}, bc={(b+c)*0.5,rotate(c-b,Pi/2)}; Point P=inter(ab,bc); return {P,dis(P,a)}; } 最小圆覆盖：随机增量法，每次加入的点若不在圆内则新圆必过该点，循环三层即可，将点集打乱后每次暴力重来复杂度是 O(n)O(n)O(n) . int n;Point P[N]; Circle min_circle() { mt19937 rd(time(0)); shuffle(P+1,P+n+1,rd); Circle c={P[1],0}; for(rint i=2;i&lt;=n;i++) if(dis(c.P,P[i])-c.r&gt;eps) { c={P[i],0}; for(rint j=1;j&lt;i;j++) if(dis(c.P,P[j])-c.r&gt;eps) { c={(P[i]+P[j])*0.5,dis(P[i],P[j])/2}; for(rint k=1;k&lt;j;k++) if(dis(c.P,P[k])-c.r&gt;eps) c=get_circle(P[i],P[j],P[k]); } } return c; } 圆反演： 圆内外的点一一映射，PPP 与 P′P&#x27;P′ 互为反演关系 ⇔\\Leftrightarrow⇔ ∣OP∣⋅∣OP′∣=R2|OP|·|OP&#x27;|=R^2∣OP∣⋅∣OP′∣=R2 且 OPP′OPP&#x27;OPP′ 共线。 不过反演圆心的圆反演后仍为圆，r′=12(1∣OA∣−r−1∣OA∣+r)R2r&#x27;=\\frac 1 2 (\\frac 1 {|OA|-r}-\\frac 1 {|OA|+r})R^2r′=21​(∣OA∣−r1​−∣OA∣+r1​)R2，过反演圆心的点反演后为两交点连成的直线。 两图形相切其对应的反演图形也相切。 应用：求过两圆外一点且与两圆相切的所有的圆。考虑以该点为反演圆心做圆反演，半径任意，那么符合条件的圆的反演为与两圆反演后的两圆的公切线，动手做点辅助线就可以推出来了。 复杂图形面积并 辛普森积分法：大致对于图形划分边界，对于每个边界内部用辛普森积分法计算，不断往下递归直到左半右半估算之和与总体估算误差很小，估算公式为 len×(f(l)+4f(mid)+f(r))/6len\\times(f(l)+4f(mid)+f(r))/6len×(f(l)+4f(mid)+f(r))/6 ，可以要求递归层数。 double f(double x) { //暴力计算横坐标x被覆盖的长度和 } double cal(double l,double r) { return (r-l)*(f(l)+4*f((r+l)/2)+f(r))/6; } double sim(double l,double r,double ans,double Eps=eps,int dep=1) { double mid=(l+r)/2,lans=cal(l,mid),rans=cal(mid,r); if(abs(lans+rans-ans)&lt;=15*Eps&amp;&amp;dep&lt;0) return lans+rans+(lans+rans-ans)/15; return sim(l,mid,lans,Eps/2,dep-1)+sim(mid,r,rans,Eps/2,dep-1); } double work() { double ans=0; for(rint i=1;i&lt;n;i++) ans+=sim(step[i],step[i+1],cal(step[i],step[i+1])); return ans; } 三角剖分 凸包：随便选一个点作为中心，把所有边作为底与该点连边就可以了。 任意多边形：若可以负面积则按凸包的做就可以了，否则 O(n2)O(n^2)O(n2) 每次暴力找一个凸角剖分递归下去，不会更优复杂度的做法。","categories":[],"tags":[{"name":"大事记","slug":"大事记","permalink":"https://saigonoinorio.github.io/tags/大事记/"}],"keywords":[]},{"title":"建站小记","slug":"建站小记","date":"2022-12-04T18:19:43.000Z","updated":"2022-12-15T17:10:09.885Z","comments":false,"path":"2022/12/05/建站小记/","link":"","permalink":"https://saigonoinorio.github.io/2022/12/05/建站小记/","excerpt":"","text":"最後の祈りを的博客，今天，成立了！ \\鼓掌/\\欢呼/ 搭博客想法其实在刚学 OI 没多久就有了，当时看到辰星凌学姐搭得多么好，不过大概是有着完美主义的坏习惯的缘故，退役了也没搞出来。（大嘘） 总之博客跌跌撞撞地是搭好了，主题是用的小学时弄 pixiv 直翻别人博客时相中的 sakura 主题，穷哥们没有服务器所以换成了静态的 hexo 版本好跑在 github 上，当时注册 github 时还不知道什么是静态动态博客，傻乎乎地传了个 wordpress 的动态版本在 github 上乱搞，之后在发现了 hexo 版本的正确使用姿势就成功 copy 好了，不过发现没有什么好写的就丢在一边了。 之后到了令和的今天，洛谷上已经丢了几篇还算有意义的文，感觉是时候重启博客企划了，所以就找了有爱♂巢经验的同学简单学了下流程（在此鸟谢 zlxFTH学长 的指导），了解了下大概原理，跟着傻瓜式教学再次搭好了博客，不过很不符现在的审美，本着强迫症的理念不断改改改成了现在的模样，不过还没有完全竣工喵，吐槽一下到处找科技最后不如嗯堆 css，总之还是很有家的感觉呐诺哒！ 为之前的博文累死累活地适配了简介和图片，还是非常有成就感哒，但感觉自己的努力与之前想的改变世界的技术宅弗如远甚，到底是哪里出了问题呢？ 立一个多多写文的 flag，写完这篇，还有三篇，往后的人生也请多多指教啦！","categories":[],"tags":[{"name":"大事记","slug":"大事记","permalink":"https://saigonoinorio.github.io/tags/大事记/"}],"keywords":[]},{"title":"背包乱学","slug":"背包乱学","date":"2022-11-04T09:21:55.000Z","updated":"2022-12-15T17:09:58.485Z","comments":false,"path":"2022/11/04/背包乱学/","link":"","permalink":"https://saigonoinorio.github.io/2022/11/04/背包乱学/","excerpt":"","text":"01背包 nnn 件物品带体积 cic_ici​ 价值 wiw_iwi​ ，选择若干个体积和 ≤V\\leq V≤V 的物品价值最大。 for(rint i=1;i&lt;=n;i++) for(rint j=all;j&gt;=c[i];j--) f[j]=max(f[j],f[j-c[i]]+w[i]); 时间 O(nV)O(nV)O(nV) ，空间 O(V)O(V)O(V) 。 完全背包 nnn 种物品带体积 cic_ici​ 价值 wiw_iwi​ 无限个，选择若干个体积和 ≤V\\leq V≤V 的物品价值最大。 for(rint i=1;i&lt;=n;i++) for(rint j=c[i];j&lt;=all;j++) f[j]=max(f[j],f[j-c[i]]+w[i]); 时间 O(nV)O(nV)O(nV) ，空间 O(V)O(V)O(V) 。 多重背包 nnn 种物品带体积 cic_ici​ 价值 wiw_iwi​ 有 numinum_inumi​ 个，选择若干个体积和 ≤V\\leq V≤V 的物品价值最大。 可以把数量二进制拆分后跑01背包，时间 O(V∑log⁡numi)O(V\\sum \\log num_i)O(V∑lognumi​) ，空间 O(V)O(V)O(V) 。 for(rint i=1;i&lt;=n;i++) { int cc=read(),ww=read(),num=read(); for(rint j=1;j&lt;num;j&lt;&lt;=1) num-=j,c[++nn]=cc*j,w[nn]=ww*j; c[++nn]=cc*num,w[nn]=ww*num; } 也可以对于每种物品通过枚举%体积的余数分开转移，利用单调队列优化转移，时间 O(nV)O(nV)O(nV)，空间 O(V)O(V )O(V) 。 for(rint i=1,ii=1;i&lt;=n;i++,ii^=1) { int c=read(),w=read(),num=read(); for(rint j=0;j&lt;c;j++) for(rint k=0,hh=0,tt=-1;j+k*c&lt;=all;k++) { while(hh&lt;=tt&amp;&amp;k-q[hh]&gt;num) hh++; if(hh&lt;=tt) f[ii][j+k*c]=max(f[!ii][j+k*c],f[!ii][j+q[hh]*c]+(k-q[hh])*w); else f[ii][j+k*c]=f[!ii][j+k*c]; while(hh&lt;=tt&amp;&amp;f[!ii][j+q[tt]*c]-q[tt]*w&lt;=f[!ii][j+k*c]-k*w) tt--; q[++tt]=k; } } 混合背包 就是背包有1、若干、无限个，按类型转移即可。 二维费用背包 多加一维即可。 bool 背包 例如求子集和之类的，bitset 优化，时空复杂度除 ω\\omegaω 。 分组背包 每组最多选一件物品，内层枚举组内即可。 树形背包 树上的背包，能否选择依赖树上的关系，朴素定义状态一般为 f[u][i]f[u][i]f[u][i] 表示 uuu 子树选 iii 个点的价值，朴素转移为 f[u][i+j]=∑f[u][i]×f[v][j]f[u][i+j]=\\sum f[u][i]\\times f[v][j]f[u][i+j]=∑f[u][i]×f[v][j] ，展开列项计算或是考虑每个点对只会在 LCA 贡献 O(1)O(1)O(1) 都可以得出 O(nk2)O(nk^2)O(nk2) 的复杂度，物品大小为1的话去掉不必要的转移则为 O(nk)O(nk)O(nk)。 树上选容量为 kkk 的带体积权值点且属于根连通块的最大权值和，朴素 O(nk2)O(nk^2)O(nk2) ，考虑对原树后序遍历后可以依次添加，f[i][j]=max(f[i−1][j−c[i]]+w[i],f[i−sz[i]][j])f[i][j]=max(f[i-1][j-c[i]]+w[i],f[i-sz[i]][j])f[i][j]=max(f[i−1][j−c[i]]+w[i],f[i−sz[i]][j]) ，省去了合并操作，就可以做到 O(nk)O(nk)O(nk) 。 树上选容量为 kkk 的带体积权值点且属于一个连通块的最大权值和，上述做法+点分治，根据主定理仍然 O(nk)O(nk)O(nk) 。 有 trick 是维护前后缀背包，可以快速计算排除某个节点不选的情况。 背包方案 具体方案和方案数都是先做一遍背包再倒过来搜。 总数量小的背包 O(2n/2)O(2^{n/2})O(2n/2) 折半搜索。 滚动前后缀背包 前缀背包显然可以滚动，滚动后缀背包考虑先求出总背包然后依次撤回，容易发现撤回其实就是倒着去掉物品的贡献。 总体积小的子集和 可以证明二进制拆分后物品总数量级别为 O(V)O(\\sqrt V)O(V​) ，然后跑01背包，时间 O(n+VV)O(n+V\\sqrt V)O(n+VV​) ，空间 O(n+C)O(n+C)O(n+C) 。 单体积小的背包 子集和 nnn 个 ≤D\\leq D≤D 的元素，求是否存在子集和为 CCC。 首先找到满足 ∑kwi≤C\\sum^k w_i\\leq C∑kwi​≤C 最大的 kkk ，把前面的取负，这样 C←C−∑kwi&lt;DC\\leftarrow C-\\sum^k w_i &lt; DC←C−∑kwi​&lt;D ，考虑定义 can(tot,l,r)can(tot,l,r)can(tot,l,r) 表示是否存在 λ∈{0,1}\\lambda \\in\\{0,1\\}λ∈{0,1} 使得 ∑i=1l−1wi+∑i=lrλiwi=tot\\sum_{i=1}^{l-1}w_i+\\sum^r_{i=l}\\lambda _iw_i=tot∑i=1l−1​wi​+∑i=lr​λi​wi​=tot ，发现固定 tot,rtot,rtot,r 则 can(tot,l,r)=1can(tot,l,r)=1can(tot,l,r)=1 的 lll 为一段前缀，同理固定 tot,ltot,ltot,l 则 can(tot,l,r)=1can(tot,l,r)=1can(tot,l,r)=1 的 rrr 为一段后缀，定义 f[tot][r]f[tot][r]f[tot][r] 表示满足 can(tot,l,r)=1can(tot,l,r)=1can(tot,l,r)=1 的最大的 lll ，显然有 f[tot][r]≤f[tot][r+1]f[tot][r]\\leq f[tot][r+1]f[tot][r]≤f[tot][r+1] ，考虑转移有 {f[tot+wr+1][r+1]←f[tot][r]f[tot][r+1]←f[tot][r]f[tot−wl][r]←l,l∈[f[tot][r−1],f[tot][r])\\left\\{\\begin{matrix}f[tot+w_{r+1}][r+1]\\leftarrow f[tot][r] &amp; &amp; \\\\ f[tot][r+1]\\leftarrow f[tot][r] &amp; &amp; \\\\ f[tot-w_l][r]\\leftarrow l,l\\in[f[tot][r-1],f[tot][r]) &amp; &amp; \\end{matrix}\\right. ⎩⎨⎧​f[tot+wr+1​][r+1]←f[tot][r]f[tot][r+1]←f[tot][r]f[tot−wl​][r]←l,l∈[f[tot][r−1],f[tot][r])​​​ 时间 O(nD)O(nD)O(nD) ，空间 O(n+D)O(n+D)O(n+D) 。 for(rint i=N-W+1;i&lt;=N;i++) dp[0][i]=0; for(rint i=N+1;i&lt;=N+W;i++) dp[0][i]=1; dp[0][N-C+sum]=st; for(int i=st;i&lt;=n;i++,ii^=1) { for(rint j=N-W+1;j&lt;=N+W;j++) dp[ii][j]=dp[ii^1][j]; for(rint j=N-W+1;j&lt;=N;j++) dp[ii][j+w[i]]=max(dp[ii][j+w[i]],dp[ii^1][j]); for(rint j=N+w[i];j&gt;N;j--) for(rint k=dp[ii][j]-1;k&gt;=dp[ii^1][j];k--) dp[ii][j-w[k]]=max(dp[ii][j-w[k]],k); } 随机打乱集合，期望过程中最值为 O(nD)O(\\sqrt nD)O(n​D) ，直接 bitset 暴力背包，时间 O(nnDω)O(\\frac {n\\sqrt nD} {\\omega})O(ωnn​D​) ，空间 O(n+nDω)O(n+\\frac {\\sqrt nD} {\\omega})O(n+ωn​D​) 。 凸函数 max 卷积 前置知识：凸函数 (max,+)(max,+)(max,+) 卷积，即求 ci=max(aj+bi−j)c_i=max(a_j+b_{i-j})ci​=max(aj​+bi−j​)，且 bbb 为凸函数 。记 cic_ici​ 在 bbb 的决策位置为 posipos_iposi​ ，那么有 posi−1≤posipos_{i-1}\\leq pos_iposi−1​≤posi​ ，可以分治做到 O(nlog⁡)O(n\\log)O(nlog) 。 01背包 物品体积 ≤D\\leq D≤D，容量为 CCC 。对于相同重量的物品，我们肯定将价值从大到小贪心取，图像为一个凸函数。因此我们将背包在模 CCC 意义下分别做 (max,+)(max,+)(max,+) 卷积即可，时间 O(nlog⁡+DClog⁡C)O(n\\log+DC\\log C)O(nlog+DClogC)，空间 O(n+C)O(n+C)O(n+C)。 完全背包 物品体积 ≤D\\leq D≤D，容量为 CCC 。注意到对于 i&gt;Di&gt;Di&gt;D，有 dpi=maxj+k=i(dpj+dpk)dp_i=max_{j+k=i}(dp_j+dp_k)dpi​=maxj+k=i​(dpj​+dpk​)，且如果 ∣j−k∣&gt;D|j−k|&gt;D∣j−k∣&gt;D，我们始终可以调整得到 ∣j−k∣≤D|j−k|≤D∣j−k∣≤D。 因此通过 [dpj−D/2,⋯,dpj+D/2][dp_{j−D/2},⋯,dp_{j+D/2}][dpj−D/2​,⋯,dpj+D/2​] 以及 [dpk−D/2,⋯,dpk+D/2][dp_{k−D/2},⋯,dp_{k+D/2}][dpk−D/2​,⋯,dpk+D/2​]，可以暴力卷积得到 dpj+kdp_{j+k}dpj+k​ 的值。 现在，假如我们知道了 [dpk−D,⋯,dpk+D][dp_{k−D},⋯,dp_{k+D}][dpk−D​,⋯,dpk+D​]，它卷自己可以得到 [dp2k−D,⋯,dp2k+D][dp_{2k−D},⋯,dp_{2k+D}][dp2k−D​,⋯,dp2k+D​]，因此采用倍增的形式可以快速计算出 [dpC−D,⋯,dpC][dp_{C−D},⋯,dp_C][dpC−D​,⋯,dpC​]，答案即为其中的最大值。 初始化的地方，暴力计算 [dp0,⋯,dp2D][dp_0,⋯,dp_{2D}][dp0​,⋯,dp2D​] 即可，时间 O(D2log⁡C)O(D^2\\log C)O(D2logC)，空间 O(n+D)O(n+D)O(n+D)。 Reference：背包，子集和以及 (max, +) 卷积在特殊情形下的求法 - wlzhouzhuan - 博客园","categories":[],"tags":[],"keywords":[]},{"title":"CSP-S 2022 琐记","slug":"CSP-S 2022 琐记","date":"2022-10-29T18:37:10.000Z","updated":"2022-12-15T17:08:49.790Z","comments":false,"path":"2022/10/30/CSP-S 2022 琐记/","link":"","permalink":"https://saigonoinorio.github.io/2022/10/30/CSP-S 2022 琐记/","excerpt":"","text":"不会写文，不过都最后一回了还是写一写，近期记忆力衰退严重不写可能就真忘了，争取写的不比去年烂，各种啥啥标点用词断句排序详略我都考虑不管了，反正我从来都没眼看自己写的东西。 day -100+ 继承到了第一部智能机 iPhoneXs，用着很舒服，考虑到我比较焦虑所以当时没啥正反馈。 受迫性被购置了一台笔记本，用着很舒服，考虑到我比较焦虑所以当时没啥正反馈。 总之新机装修还是good爽啊，反正我从小就喜欢这个，可能比较类似于收集癖之类的，感觉不用展开讲。 离开了北海来到了森萌找到了师傅，牛校出牛子，被小两年的牛子随意吊打，之前学的太自闭了，热闹点学起来还是很快乐的。 时间过得就是很快，发生的很多已经记不到了，我个人可能极度右倾，不会适应环境和社交之类的，操作就非常变形非常拉垮，只能劝自己看开点算了。 day -50+ 自然而然的发展了一些娱乐活动，可能需要稍微回想一下，摸了几手游戏还是很控制剂量的，vcb复活了去偷了手播放器，看了takagi3，Arcane，93589，C100，反正不谈琐碎的话，确实我人生的轨迹都是这些点缀的，现实确实没啥爱好不感兴趣，只能说还是要爱惜记忆力，已经开始记不住很多东西了，另外还看了很多很棒的应该也没必要列举了，还是不断有新元素，之前文化课的时候确实是精神营养不良，人都低俗了一截，现在境况还是非常不错的。 反正几天的暑假就这样过去了，尽力去做了些有意义的事情，至少现在我还记得到。 然后是疫情封控，操作就非常的迷惑，感觉就极其自闭，越打越烂越烂越自闭，印象上反正就是特别低谷，反正后面就烂到每天一两点过睡了，作息就一拓答辩，后面的生物钟也是乱到现在，反正就考虑不管了身体已经习惯了，应该也是加剧了头疼记忆力衰退，不过以前也是这个鬼样，因素还是很多的，可能还是考虑解决某些根源上的问题，不过确实要慢慢往前多调调了，道理还是很显然的，只能说尽量，因为我现在就在熬夜码这些字我也不晓得我为啥子要早睡为啥子不早睡。 还是尝试了很多以前没试过的东西，还是非常刺激的，不晓得好久以前留下的了，反正就是啥子都要去试一下，新事物的体验是绝无仅有的，有一种人类野性的美。 day -10+ 首先刨去一车没营养把把垫底的联考。 体育活动还是很好的，唤起了很多肌肉记忆，非常神奇的，应该也唤起了很多激素之类的，精神好了很多，我都一年多没上过体育课了，关于体育课纯粹好耍的记忆好像都停在了小学，可能是我本来就不喜欢正经竞技类体育运动的缘故。 想不起来有啥子可以写的了，社交感觉达到了正常人标准，可喜可贺可喜可贺。 day -7+ 回了北海，到了就鼻炎恶化以及某种眼部疾病，隔离两天摆了两天，吃了药可能有红茶效果九点钟就睡了，第二天人就正常了很多，看上去早睡可以解决大多数问题。 整了个模版补完计划，pr没多少，不过还是超过了期望，博客啥的考虑需求层次理论还是咕咕咕算了。 想板刷ACwing自己还是太拉了，考虑画大饼是人类通病。 回了北海机房看到一片狼藉，新一届的卫生安全学术都太拉垮了，虽然当时的我还在学搜索之类的，条件也没有现在这么好，但至少基本节操得有，现在回头看来学好确实需要一些重要的东西，我不认为他们会比我强，不过应该有个别正常人，考虑不管，北海确实是烂完了。 翻了翻教练搬过来的旧书，一车闻所未闻的远古oi教辅，看了下16年的wc白皮书，发现原来beats也是在北海讲的，真的是祖上荣光，难以想象是怎么烂得这么快的。 学了手NoiLinux和Arbiter的使用，感觉还是有必要开虚拟机。 打了csp2020和csp2021，随意300+，不是很理解以前的我在搞马，不过信心确实很重要的，实力弱不管，心态一定要好，考虑人类种。 day 1 昨天打了模版洗了澡陶冶了情操，早上起来又洗了个澡，执行的非常棒，就是中午润去西橙的时候家长安排紊乱拖了很多行李很乱很匆忙，大概内心想法和Sheldon是一样的。 总之到了西橙，还是有很多感慨不过要考试所以考虑不管，进去了之后感觉比去年随意了很多，少了很多新鲜感，发现了今年北海人还是比较多，然后听到了有佬在弹钢琴，下意识听成了ab的曲，吓了一跳，然后发现不是。 上楼进了考场，操作比去年自然熟练了不少，终于像个正常人了，发现旁边的同学在敲键盘，于是我也开敲，调了下Dev设置敲完缺省源，尝试打开虚拟机，发现有密码，我不知道密码，可能是因为省选的阴影没有问监考老师，试密码试到开考也没试出来，给自己定的预期目标是一定要300+。 下发了压缩包，题目名字都比较高级，没有bracket这种毒瘤名字其实也不慌。 慢慢仔细的读完了T1，题意很清晰，所以就尝试去切，胡乱想了很多，还是没有什么好的思路，期望0.5h切掉结果40min还没好的思路，不过这次心态比较稳，于是冷静的去读了T2，感觉一眼秒了又看了一遍，确认切了准备去看T3，发现题目比较长准备之后再来读，于是开码T2线段树，大概10min多写完，但是样例挂了又很难手玩，于是下决心写了个对拍，然后手玩改改改，大概花了30min顺利切掉。 回头想T1又绕了一些弯路，忽然就提醒了自己一下这是T1，过了一下往年的难度于是开始换弱智思路，发现自己确实被诈骗了就快速码了个mx123，样例很水一下就过了，这个时候总时间过去了大概1h40min。 开始读T3，非常顺利地读完了，感觉暴力随便写但是正解没有好的思路，于是去看T4，T4题意很清晰不过有种T1的既视感，想了个假暴力做法但是跟T4难度不服，觉得自己肯定假但是很好写，于是先码再说，码完发现过不了样例观察出了假点，dfs改成bfs暴力就写好了。 准备回头写T3，算了算自己毛估估300，已经达到预期，于是对拍T1求稳，很顺利地拍完了，这时大概还剩1.5h，准备开始写T3暴力，我还没想好怎么判定于是先写完操作，写完发现判定很简单，于是稍微改了下顺利过了样例。 回头看T4，暴力档很多，不过看到特殊性质分很多于是不管k=1和k=2去想特殊性质，发现很简单于是开写，锅了就手玩样例慢慢调出来了，中途还去T3随意写了写两个10分的部分，随便加了个卡时，也没有打算正经拿分，调T4最后花了挺多时间，大概在结束前10min调出来了，反复瞪了几遍四道题没有发现问题就准备交卷了。 考完才发现自己一口水都没喝也没上厕所，也没有注意到有人去上厕所，意识到今天发挥很正常，潜意识惋惜了下去年的自己。 出了西橙校门发现天都黑完了啥也看不清，然后就光速坐上营养快线了。 估分：100+100+50+68=318 CCF：100+100+95+68=363 day2 凌晨确实是day2，写了这篇文章，完结撒花花。 Tenshi","categories":[],"tags":[{"name":"大事记, 心音","slug":"大事记-心音","permalink":"https://saigonoinorio.github.io/tags/大事记-心音/"}],"keywords":[]},{"title":"NOIP 数学简结","slug":"NOIP 数学简结","date":"2022-09-23T02:31:59.000Z","updated":"2022-12-15T17:10:18.965Z","comments":false,"path":"2022/09/23/NOIP 数学简结/","link":"","permalink":"https://saigonoinorio.github.io/2022/09/23/NOIP 数学简结/","excerpt":"","text":"素数和约数 素数判定 O(n)O(\\sqrt n)O(n​)：枚举≤n\\leq \\sqrt n≤n​的数看是否能整除。 O(klog⁡n)O(k\\log n)O(klogn)：Miller-Rabin算法，k一般取10，最好取前12个质数LL内稳定判素. bool Miller_Rabin(int x) { if(x&lt;3||!(x&amp;1)) return x==2; int a=x-1,b=0; while(!(a&amp;1)) a&gt;&gt;=1,b++; int k=10; while(k--) { __int128 y=qp(rd()%(x-2)+2,a,x); if(y==1) continue; bool can=0; for(rint i=1;i&lt;=b;i++) { if(y==x-1) {can=1;break;} y=y*y%x; } if(!can) return 0; } return 1; } 筛法 O(nlog⁡log⁡)O(n\\log\\log)O(nloglog)：埃氏筛，枚举素数倍数，注意剪枝。 void ishai(int n) { susu[++tot]=2; for(rint i=3;i&lt;=x;i+=2) if(!use[i]) { susu[++tot]=i; for(rint j=i*i;j&lt;=x;j+=2*i) use[j]=1; } } ​ O(n)O(n)O(n)：欧拉筛，利用是否为素数为积性函数来筛，还可以在此过程中记录每个数的一个素因子做到 O(log⁡)O(\\log)O(log) 分解质因数，对于筛积性函数需要定义 f(p)f(p)f(p) 和 f(pk)f(p^k)f(pk) ，并且记录 lowilow_ilowi​ 表示 iii 的最小素因项。 void oshai(int n) { for(rint i=2;i&lt;=n;i++) { if(!use[i]) susu[++tot]=i; for(rint j=1;j&lt;=tot&amp;&amp;i*susu[j]&lt;=n;j++) { use[i*susu[j]]=1; if(!(i%susu[j])) break; } } } void ex_oshai(int n) { f[1]=1; for(rint i=2;i&lt;=n;i++) { if(!use[i]) susu[++tot]=i,f[i]=f_p; for(rint j=1;j&lt;=tot&amp;&amp;i*susu[j]&lt;=n;j++) { use[i*susu[j]]=1; if(!(i%susu[j])) { low[i*susu[j]]=low[i]*susu[j]; if(low[i]==i) f[i*susu[j]]=f_p_k; else f[i*susu[j]]=f[i/low[i]]*f[low[i]*susu[j]]; break; } low[i*susu[j]]=susu[j]; f[i*susu[j]]=f[i]*f[susu[j]]; } } } 数论分块 利用 ⌊ni⌋\\left \\lfloor \\frac{n}{i} \\right \\rfloor⌊in​⌋ 只有n\\sqrt nn​种取值，相同取值的一起计算即可，r=n/n/lr=n/n/lr=n/n/l，k维数论分块是 O(kn)O(k\\sqrt n)O(kn​) 的。 最大公约数 具有可并性，可以用st表/线段树维护。 不断添数的话，总体的 gcd⁡\\gcdgcd 只会变化 log⁡\\loglog 次。 可以拆位，转化为对各质因数的幂次取min，lcm同理。 同余 裴蜀定理 ax+by=gcd⁡(a,b)ax+by=\\gcd(a,b)ax+by=gcd(a,b)必有一组整数解 (x,y)(x,y)(x,y)，可以拓展到多个的情况。 进一步结论：满足 ax+by=n(x,y,a,b∈N)ax+by=n(x,y,a,b\\in N)ax+by=n(x,y,a,b∈N) 有解的 nnn 任意一对满足 ni+nj≠a∗b−a−bn_i+n_j\\ne a*b-a-bni​+nj​=a∗b−a−b. 同余方程 扩欧可求 ax+by=gcd⁡(a,b)ax+by=\\gcd(a,b)ax+by=gcd(a,b) 的一组可行解，一解可得任意解，由此可求同余方程 ax≡1(modb)ax\\equiv 1\\pmod bax≡1(modb) 解。 void exgcd(int a,int b,int &amp;x,int &amp;y) { if(!b) return x=1,y=0,void(); exgcd(b,a%b,x,y); swap(x,y),y=y-(a/b)*x; } 扩展欧拉定理 ab≡{ab%φ(p)gcd⁡(a,p)=1abgcd⁡(a,p)≠1,b&lt;φ(p)ab%φ(p)+φ(p)gcd⁡(a,p)≠1,b≥φ(p)(modp)\\begin{equation} a^b\\equiv \\begin{cases} a^{b\\% \\varphi(p)}&amp;\\gcd(a,p)=1\\\\ a^b&amp;\\gcd(a,p)\\neq 1,b&lt;\\varphi(p)\\\\ a^{b\\%\\varphi(p)+\\varphi(p)}&amp;\\gcd(a,p)\\neq 1,b\\geq\\varphi(p) \\end{cases} \\pmod p \\end{equation} ab≡⎩⎨⎧​ab%φ(p)abab%φ(p)+φ(p)​gcd(a,p)=1gcd(a,p)=1,b&lt;φ(p)gcd(a,p)=1,b≥φ(p)​(modp)​​ 费马小定理 对于 p∈prime&amp;gcd⁡(a,p)=1p\\in prime\\&amp;\\gcd(a,p)=1p∈prime&amp;gcd(a,p)=1，有 ap−1=1a^{p-1}=1ap−1=1 . 可用于求解逆元。 威尔逊定理 ppp 为素数 ⇔\\Leftrightarrow⇔ (p−1)!≡−1(modp)(p-1)!\\equiv -1\\pmod p(p−1)!≡−1(modp). 乘法逆元 O(log⁡)O(\\log)O(log) 快速幂，适用于满足费马小定理的情况. O(log⁡)O(\\log)O(log) 扩欧，即求解同余方程 ax≡1(modp)ax\\equiv1\\pmod pax≡1(modp)，gcd⁡(a,p)≠1\\gcd(a,p)\\ne 1gcd(a,p)=1 时无解。 O(n)−O(1)O(n)-O(1)O(n)−O(1) 预处理。 inv[1]=1; for(rint i=2;i&lt;=n;i++) inv[i]=(p-p/i)*inv[p%i]%p; 扩展中国剩余定理 求解模线性同余方程组 {x≡b1 (mod a1)x≡b2 (mod a2)...x≡bn (mod an)\\begin{cases} x \\equiv b_1\\ ({\\rm mod}\\ a_1) \\\\ x\\equiv b_2\\ ({\\rm mod}\\ a_2) \\\\ ... \\\\ x \\equiv b_n\\ ({\\rm mod}\\ a_n)\\end{cases}⎩⎨⎧​x≡b1​ (mod a1​)x≡b2​ (mod a2​)...x≡bn​ (mod an​)​ 考虑如何将两方程合并为一个，考虑将 xxx 写成两个含待定系数方程的形式，则可列等式，发现是一个不定方程的形式，先用裴蜀定理判无解，再用扩欧求一组特解，回代求出一个特定的 xxx ，那么新的 a=lcm(a1,a2),b=x%aa=lcm(a_1,a_2),b=x\\%aa=lcm(a1​,a2​),b=x%a . 组合数学 二项式定理 (a+b)n=∑(ni)aibn−i(a+b)^n=\\sum \\binom n i a^ib^{n-i}(a+b)n=∑(in​)aibn−i , (∑txi)n=∑(nn1,n2,...,nt)∏txini(\\sum^t x_i)^n=\\sum \\binom n {n_1,n_2,...,n_t} \\prod^t x_i^{n_i}(∑txi​)n=∑(n1​,n2​,...,nt​n​)∏txini​​ 多重排列组合 多重集排列数=多重组合数= (nn1,n2,...,nt)\\binom n {n_1,n_2,...,n_t}(n1​,n2​,...,nt​n​) = n∏tni!\\frac n {\\prod^t n_i!}∏tni​!n​ 多重集组合数：若选择数&lt;=最小数量，则问题等价于 ∑kxi=r\\sum^k x_i=r∑kxi​=r 的非负整数解数目，插板法可得 ans=(r+k−1k−1)ans=\\binom {r+k-1} {k-1}ans=(k−1r+k−1​) . 否则考虑容斥原理枚举哪些数选完，ans=∑p=0k(−1)p∑∣A∣=p(k+r−1−p−∑nAik−1)ans=\\sum _{p=0}^k(-1)^p\\sum_{|A|=p} \\binom {k+r-1-p-\\sum n_{A_i}} {k-1}ans=∑p=0k​(−1)p∑∣A∣=p​(k−1k+r−1−p−∑nAi​​​) 不相邻组合 nnn 个相同物品选 kkk 个不相邻的= (n−k+1k)\\binom {n-k+1} k(kn−k+1​) ，理解为在 n−kn-kn−k 个数里插 kkk 个不相邻的隔板。 圆排列 (n−1)!(n-1)!(n−1)! ，考虑任何一种普通排列都有n种等价圆排列。 错排 Dn=(n−1)(Dn−1+Dn−2)=nDn−1+(−1)n=n!∑(−1)ii!D_n=(n-1)(D_{n-1}+D_{n-2})=nD_{n-1}+(-1)^n=n!\\sum \\frac {(-1)^i} {i!}Dn​=(n−1)(Dn−1​+Dn−2​)=nDn−1​+(−1)n=n!∑i!(−1)i​ 组合恒等式 比例公式 (nk)=nk(n−1k−1)\\binom n k=\\frac n k \\binom {n-1} {k-1} (kn​)=kn​(k−1n−1​) 二项式定理特例 ∑(−1)i(ni)=[n=0]\\sum (-1)^i\\binom n i=[n=0] ∑(−1)i(in​)=[n=0] 范德蒙德卷积 ∑(ni)(mm−i)=(m+nm)\\sum \\binom n i \\binom m {m-i}=\\binom {m+n} m ∑(in​)(m−im​)=(mm+n​) 范德蒙德卷积特例(n=m) ∑(ni)2=(2nn)\\sum \\binom n i ^2=\\binom {2n} n ∑(in​)2=(n2n​) 组合数带权和 ∑i(ni)=n2n−1\\sum i\\binom n i=n2^{n-1} ∑i(in​)=n2n−1 对消公式 (nm)(mk)=(nk)(n−km−k)\\binom n m\\binom m k=\\binom n k\\binom {n-k} {m-k} (mn​)(km​)=(kn​)(m−kn−k​) 自卷公式 ∑(n−ii)=Fibn+1\\sum \\binom {n-i} i=Fib_{n+1} ∑(in−i​)=Fibn+1​ 吸收公式 (nk)k=(n−1k−1)n\\binom n k k=\\binom {n-1} {k-1} n (kn​)k=(k−1n−1​)n (nk)(n−k)=(n−1k)n\\binom n k (n-k)=\\binom {n-1} k n (kn​)(n−k)=(kn−1​)n 平行求和 ∑k(n+ii)=(n+k+1k)\\sum^k \\binom {n+i} i=\\binom {n+k+1} k ∑k​(in+i​)=(kn+k+1​) 上指标求和 ∑n(ik)=(n+1k+1)\\sum^n \\binom i k=\\binom {n+1} {k+1} ∑n​(ki​)=(k+1n+1​) 下指标差求和 ∑k(ni)(−1)i=(−1)k(n−1k)\\sum ^k \\binom n i (-1)^i=(-1)^k\\binom {n-1} k ∑k​(in​)(−1)i=(−1)k(kn−1​) Lucas定理 (nm)≡(n/pm/p)×(n%pm%p)(modp)\\binom n m\\equiv \\binom {n/p} {m/p} \\times \\binom {n\\%p} {m\\%p} \\pmod p (mn​)≡(m/pn/p​)×(m%pn%p​)(modp) 卡特兰数 Hn=∑Hi−1Hn−i=Hn−1(4n−2)n+1=(2nn)n+1=(2nn)−(2nn−1)H_n=\\sum H_{i-1}H_{n-i}=\\frac {H_{n-1}(4n-2)} {n+1}=\\frac {\\binom {2n} n} {n+1}=\\binom {2n} n -\\binom {2n} {n-1} Hn​=∑Hi−1​Hn−i​=n+1Hn−1​(4n−2)​=n+1(n2n​)​=(n2n​)−(n−12n​) ​ 含义：① nnn 个 111 和 nnn 个 −1-1−1 排列使得无负前缀的方案数、② n×nn\\times nn×n 网格从左下到右上且不穿对角线的非降路径数、③ 圆上 2n2n2n 个点划 nnn 条线段不交的方案数、④ n+2n+2n+2 个点的凸多边形三角剖分方案数、⑤ 长为 nnn 的出栈序列数量、⑥ nnn 个点的二叉树形态数。 斯特林数 第二类斯特林数： {nk}{n \\brace k}{kn​} 即 S(n,k)S(n,k)S(n,k) ，表示将 nnn 个数分为 kkk 个非空集合的方案数. {nk}={n−1k−1}+k{n−1k}=∑m(−1)m−iini!(m−i)!{n \\brace k}={n-1 \\brace k-1}+k{n-1 \\brace k}=\\sum^m \\frac {(-1)^{m-i}i^n} {i!(m-i)!} {kn​}={k−1n−1​}+k{kn−1​}=∑m​i!(m−i)!(−1)m−iin​ 第一类斯特林数： [nk]{n \\brack k}[kn​] ，表示将 nnn 个数分为 kkk 个圆排列的方案数。 [nk]=[n−1k−1]+(n−1)[n−1k]{n \\brack k}={n-1 \\brack k-1}+(n-1){n-1 \\brack k} [kn​]=[k−1n−1​]+(n−1)[kn−1​] 十二重计数法 球不同盒不同：mnm^nmn、 球不同盒不同无空：∑m(−1)i(mi)(m−i)n\\sum^m (-1)^i\\binom m i (m-i)^n∑m(−1)i(im​)(m−i)n （容斥） 球不同盒同：∑m{ni}\\sum^m {n \\brace i}∑m{in​} 球不同盒同无空：{nm}{n \\brace m}{mn​} 球同盒不同：(n+m−1m−1)\\binom {n+m-1} {m-1}(m−1n+m−1​) 球同盒不同非空：(n−1m−1)\\binom {n-1} {m-1}(m−1n−1​) 球同盒同：DP，Fn,m=Fn−m,m+Fn,m−1F_{n,m}=F_{n-m,m}+F_{n,m-1}Fn,m​=Fn−m,m​+Fn,m−1​，考虑全部+1或添0即可 球同盒同非空：Fn−m,mF_{n-m,m}Fn−m,m​ 线性代数 矩阵乘法 具有结合律没有交换律，可以做快速幂，可以循环展开优化常数。 加速递推、作为表达修改的tag 定长路径统计：定长路径数量即做k次邻接矩阵的矩乘，定长最短路即做k次邻接矩阵的floyd，若统计的是 ≤\\leq≤ 加上自环即可。 高斯消元 逐步消成对角矩阵即可，当前元要找所在列中系数绝对值最大的一行，然后对其他行消除该元即可。 解n元一次方程组，答案即为第n+1列。 计算行列式：交换两行时答案取反，最终答案即为对角上的数乘积。 求逆矩阵：在原矩阵右边拼上一个单位矩阵，把左边消成单位矩阵右边就是逆矩阵了，消不出来则无解。 异或方程组：解法同理。 线性基 一般指异或线性基，维护数集的异或集合(不含0，如要统计则考虑e[0]后记录是否出现0，没有被选进线性基的数可等价看作为0)，可以贪心构造，维护点对的异或集合是01trie。 void insert(int x) { for(rint i=50;~i;i--) if(x&gt;&gt;i&amp;1) { if(!e[i]) {e[i]=x;break;} x^=e[i]; } } 异或线性基的大小只有 log⁡V\\log VlogV，合并只能逐个插入是 O(log⁡2)O(\\log ^2)O(log2) 的，区间线性基可以用前缀线性基来贪心维护，额外维护时间信息，相异或时swap留下时间更大的一项即可。 实数线性基：考虑异或线性基的01改成了实数，性质是相同的，复杂度会高一维。","categories":[],"tags":[{"name":"noip, 算法, 梳理","slug":"noip-算法-梳理","permalink":"https://saigonoinorio.github.io/tags/noip-算法-梳理/"}],"keywords":[]}]}