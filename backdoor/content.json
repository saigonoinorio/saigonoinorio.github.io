{"meta":{"title":"最後の祈りを","subtitle":null,"description":null,"author":"me","url":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2023-05-01T09:57:17.903Z","comments":false,"path":"about/index.html","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/about/index.html","excerpt":"","text":"🥺","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2023-03-13T17:10:13.717Z","comments":false,"path":"bangumi/index.html","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"client/index.html","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2023-03-13T17:46:00.116Z","comments":true,"path":"comment/index.html","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/comment/index.html","excerpt":"","text":"念一句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》 更幼的诗 下床着新衣，初学小姑拜。 低头羞见人，双手结裙带。 【明代】毛铉《幼女词》","keywords":"留言板"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"lab/index.html","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/lab/index.html","excerpt":"","text":"sakura主题 balabala","keywords":"Lab实验室"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2023-03-13T16:14:33.204Z","comments":false,"path":"donate/index.html","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2023-03-13T18:13:05.907Z","comments":false,"path":"music/index.html","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/music/index.html","excerpt":"","text":"","keywords":"音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"rss/index.html","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"tags/index.html","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2023-03-13T16:17:30.465Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2023-03-13T16:24:04.915Z","comments":true,"path":"links/index.html","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2023-03-13T16:15:13.064Z","comments":false,"path":"video/index.html","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"book-list","date":"2018-12-20T15:13:05.000Z","updated":"2023-05-01T09:46:46.644Z","comments":false,"path":"book-list/蒲公英女孩/index.html","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/book-list/蒲公英女孩/index.html","excerpt":"","text":"蒲公英女孩 Robert Franklin Young 山上的那个女孩使马克想起了埃德娜·文森特·米莱。 或许是因为她站在午后的阳光下，而她那蒲公英般色泽的头发则在风中起舞；又或许是因为她那老式的白色连衣裙缠绕着其修长而苗条的双腿。无论如何，马克都有个强烈的感觉便是那位女孩来自过去，然而事实证明这个感觉是错误的，女孩并非来自过去，而是未来。 马克在女孩身后的不远处停住了，他的呼吸由于登山的缘故显得有些急促。女孩还没有发现他，而他也正在考虑如何使女孩知晓他的存在，而又不至于受到惊吓。当他下定决心之后，他便取出烟斗，填满烟叶，点着它，并用手护住烟斗，猛吹几口直到烟叶完全被点燃。当马克再望向女孩时，女孩已经转过头来，正好奇地打量着他。马克慢慢地走向女孩，享受微风轻轻拂过脸颊的快感，明显地感觉到天空变得更近了。他暗暗告诉自己，以后要经常进行徒步旅行。 在到达这座小山之前，他曾不时地穿过一片树林，而此时那边树林早已远远地落在他身后，一片淡黄，似乎在这浅浅的秋意中慢慢燃烧着。在树林的那一边有一个小湖，湖边的小屋和钓鱼的桥墩与小湖似乎融为了一体。在妻子被意外地召去履行陪审义务之后，马克只能独自一人打发从暑假中挤出的两周时间，白天钓鱼，夜晚则在客厅的大壁炉前看书。在过了两天这样有规律的生活之后，马克出发进入了那片树林，漫无目的和方向地走着，直到他到达了这座山，看到了那个女孩。 女孩的眼睛像天空一般蔚蓝，而天空也似乎也成了她那苗条轮廓的外框。她那鹅蛋般的脸庞柔软而又甜美。这种似曾相识的感觉使得马克非常地痛苦，因为他必须强忍住自己内心的冲动——想要伸手摸一摸她那被风轻吻的精致脸颊的冲动。尽管自己的手并未离开身旁，但马克却似乎感觉到指尖隐隐作痛。怎么会这样？我已经44岁了，而她顶多刚过20岁，是什么抓住了我的心？马克心里波浪起伏。 “嗨，你喜欢这里的风景吗？”他大声问道。 “哦，是的”，女孩边说边转过身去并将手环绕在身前。“这里简直太迷人了。” 马克随着女孩的眼光望去，嘴里不禁念道：“是啊，确实如此”。 在他们脚下，那片树林，以一种暖秋的色调再次向前方的低地铺展出去，在环绕过几里外的一个小村落后，最终在远处边境的一个村落前从容褪开。在远处，薄雾使小湾城那锯齿状的轮廓变得柔和起来，并赋予了它中世纪城堡的外貌，使它看来更象是在梦里而非现实中。 “你也是来自于那座城市吗？”马克问道。 “在某种程度上是的。”女孩微笑地望着她，“我来自于240年后的小湾城。” 这个笑容让马克意识到女孩并非真的认为马克会相信她，但是如果马克假装相信的话却也不错。因此，马克也笑了：“那一定是公元2201年，是吧？我想到那时小湾城会变得很大？” “哦，是的”，女孩指着他们脚下的树林边缘，说道：“那时这里将是人口稠密带，第2040号大街正好穿过那片糖枫林。你看到那群蝗虫所在的地方了吗？” “是的”，马克说，“我看到了。” “那是一个新购物中心的所在地。它的超级市场是如此巨大，以至于你需要花上半天的时间才能穿过它。在那里，你可以购买到从阿斯匹林到陆空两用运输器等等在内的几乎所有你想要的东西。在超级市场旁边，也就是那片山毛榉树林所在的位置，有一间大型女装商场，里面专门销售顶级女装设计师的最新设计。我穿的这件连衣裙就是今天早上在那里买的，很漂亮吧？” “哦，是的。”不过，我可不相信这裙子是240年后的产物。马克心里虽然这么想，表面上却很有礼貌地观察着那件连衣裙。裙子是用一种未曾见过的材料剪裁而成的，这种材料似乎是由棉花糖、海水泡沫以及雪花混合而成的。这大概是女孩自己做的衣服吧，马克边想边说道：“我猜你是乘坐时间机器来的吧？” “是的，我父亲发明了一台时间机器。” 马克端详着女孩，他从未见过如此坦诚的一张脸，“那你经常来这里吗？” “哦，是的。这里是我最喜欢的‘时光坐标’，我有时在这里站上好几个小时，不停地看这看那。前天我看见了一只兔子，昨天是一头鹿，而今天则是你。” “可怎么会有昨天呢”，马克问道：“如果你总是按时回到同一个地点的话？” “哦，我明白你的意思”，女孩说：“那是因为那个时间机器同其他事物一样也是受时间影响的，因此如果你想要保持相同的‘时光坐标’的话，你必须每隔24个小时就将它的钟表指针往回拨，而我没有这样做，那是因为我更喜欢每次回来时都是不同的一天。” “那你父亲有跟你回来过吗？” 女孩并没有马上回答马克，她抬起头来，一群“V”字型的天鹅正懒洋洋地从他们头顶飞过，女孩出神地看了好一会，才说道：“我的父亲现在病了，他一定非常想来，如果他身体允许的话，不过没关系，我把我所看到的全部都告诉他了。” 女孩又急忙补充道：“那就好像他亲自来到这里一样，你说是吧？” 马克看着女孩那期待的眼神，心里一阵感动：“是的，肯定是那样的”，接着他又说道：“有一台时间机器一定很棒吧！” 女孩严肃地点点头：“这对于喜欢草地的人们来说是一种恩惠，在23世纪，已经几乎没有多少草地了。” 马克笑了，说道：“是啊，即使是二十世纪的今天，也已经没有多少草地了，我猜你肯定会说这片草地是属于某个收藏家的吧，看来我以后得经常来这里，呵呵。” “你住在这附近吗？”女孩问。 “我住在后面三里远的一个小屋里，原本是来度假的，可现在却不是这么一回事了，我的妻子由于要履行陪审义务，因此不能和我一道来这里度假，而我又不能推迟这个假期，因为我已经累得像个梭罗了。我叫马克.伦道夫。” “我叫朱莉”，女孩说，“朱莉.丹弗斯。” 这名字就像这条白色连衣裙一样很适合她，还有这蓝色的天空、小山以及这九月的微风都很适合她。或许她就住在这树林里的某个小村落…但是这并没有关系，如果她想假装来自未来，那就让她继续装下去好了。马克真正在意的是他第一眼看到女孩时，那种心动的感觉，以及端详女孩那温柔的脸蛋时所产生的嫩滑感。 “你从事什么工作呢，朱莉？”马克问道，“或者你还是个学生吗？” “我还在读书，正努力成为一名秘书。”朱莉回答道，她向前走了半步，做了一个漂亮的旋转，将手环绕在自己胸前。 “我真的非常想成为一名秘书”，朱莉接着说道：“你想，在一个很重要的大办公室里，将那些重要人物的谈话记录下来，这是多么非凡的一项工作啊！想让我成为你的秘书吗，伦道夫先生？” “我非常愿意”，马克说，“我的妻子就曾经是我的秘书。哦，那是战前的事了，那也是我们俩相识的原因。”哦，我怎么会说起这个，马克自己都有点惊讶。 “她是个好秘书吗？”朱莉问。 “她是最好的，我很遗憾后来她不再是我的秘书了，不过她却成为了我的妻子，这或许就是所谓的‘失之于朝，得之于野’吧。” “呵呵，是的，确实如此。哦，伦道夫先生，我得回去了，我父亲正在家里急着听我今日的见闻呢，而且我也得回去给他准备晚饭了。” “明天你还会来这里吗？” “应该会吧，我最近每天都有来这，再见了，伦道夫先生” “再见，朱莉。” 马克看着女孩轻巧地跑下山，消失在那片糖枫林中——也就是240年后，第2040号大街的所在地。马克笑了，心想：多么可爱的女孩啊。一种难以抑制的好奇心就如同对生命的热情一样令马克全身颤抖起来。正因为曾经否认过这两种价值，因此此刻，马克更能体会它们的重要性。 20岁时，他是个严肃的年轻人，通过自己的努力考取了法学院；24岁时，他就拥有了自己的事业，虽然那时事业还小，可却占据了他的全部——哦，好吧，并非全部，当他与安妮结婚时，曾经有一段短暂的时期——工作在某种程度上失去了它的紧迫感。接着，随着战争的来临，又有一段时期——这次要长的多——工作不仅变得遥远，甚至在某些时候还有些卑鄙。然而，在他回归平民生活之后，工作的紧迫感又回来了而且似乎报复般的更加紧迫，因为此时，他不仅要抚养妻子，还有儿子杰夫。于是从那个时候到现在，马克便被自己的工作占据了生活的全部，除了每年四个礼拜的假期——而这也是他最近几年才允许自己享有的。前两个礼拜，他会和安妮、杰夫一起去后者所挑选的某个旅游胜地；后两个礼拜，也就是在杰夫回学校以后，他会和安妮两人独自呆在他们湖边的小屋里。然而，今年他也许只能独自一人度过那两个礼拜了。唔，或许并非是单独一人。 马克的烟斗不知何时已经熄灭了。他再次将它点燃，深吸一口，慢慢地走下山，动身返回那片树林，朝着小屋的方向走去。 秋风已至，白天的长度逐渐变短，而夜晚的潮湿也已开始侵袭这雾色朦胧的天空。马克走得很慢，当他回到湖边时太阳已经落山了。这是一个小湖，但却很深，树木沿着湖畔延展开来。小屋就在距离湖边不远处的一排松树下，一条曲折的小路将它和钓鱼的桥墩连接在一起。小屋后面有一条泥路与高速公路相通，而马克的旅行车就停在后门边上，随时准备将其载回文明社会。马克在厨房随便地吃了点东西，吃完后，他便回到起居室看书。屋外小棚里的发电机不时地传来一阵嗡嗡声，但这早已被现代人的耳朵所习惯的吵杂声并未打破夜的寂静。马克从壁炉旁那精心准备的书架上挑出一本美国诗集，坐了下来，翻到《小山上的午后》这一页，他将这首宝贵的诗来回读了三遍，每读一遍他便仿佛看到那女孩站在午后的阳光下，她的长发在风中起舞，她的连衣裙则像柔和的雪花般缠绕在她那修长而又可爱的双腿上……忽然有一种块状物涌上了马克的喉咙，使他难以下咽。 马克将书放回了书架，走出小屋，站在门廊上，他再一次点燃了手中的烟斗。马克开始强迫自己想安妮，不多时，安妮的脸便呈现在他眼前：坚实而又温和的下巴，温柔而又富有同情心的双眼，尽管里面总有一丝马克至今无法了解的恐惧，还有那依旧柔软的脸颊以及那优雅的微笑。这些所有的优点都在她那波动的浅棕色长发以及那高挑身材、优美身姿的映衬下显得更加引人注目。每当马克想起自己的妻子，他总会惊叹于她那似乎永远不老的脸庞，惊叹于他如何能在这么多年后依旧像多年以前的那个早上——马克第一眼见到她时那样可爱。因此，很难想象仅仅过了20年之后，自己竟会那么期待与一个按年龄几乎可以做自己女儿的接近于虚构的一个女孩约会。哦，不是这样的——但似乎也不是完全无法想象，马克立刻摇摆起来。有一阵子，马克甚至感觉自己的身体似乎离开了自己，完全无法掌握。所幸，过了不久，双腿又重新回到了他的控制之下，而这个世界似乎也回复到其原本健康有序的轨道上。马克熄灭了烟斗，重新回到了屋里。在卧室里，他脱了衣服，钻进被窝并关上了灯。梦乡本应很容易地到来，但却没有，等到它最终来临时，却是一些穿插着许多急促的梦的碎片。 “前天我看见了一只兔子”，女孩说，“昨天看见了一头鹿，而今天则遇见了你。” 第二天下午，女孩穿着一件蓝色的连衣裙，用一条蓝色的丝带绑住她那蒲公英般色泽的长发。马克在到达山下后，站了一会，一动也不动，直到他那绷紧的喉咙放松下来，他才走上山去，站在女孩的身旁。但女孩那具有柔和曲线的脖子和下颚却令他的喉咙再度绷紧起来。因此当女孩转过身来向他说： “嗨，我还以为你不会来了。” 马克停了好长一会才回答道：“但我还是来了，你也是。” “是的。”女孩说，“我很高兴你能来。” 他们俩在附近一些露出地面的花岗岩上坐了下来，俯望着山下的风景。马克点燃了烟斗开始抽烟，并朝风中吐出烟圈。 “我父亲也吸烟斗，”女孩说，“当他点烟叶时，也像你那样，用手护住烟斗，即使一点风也没有。你和我的父亲在好多地方都很相像。” “给我讲讲你父亲吧，”马克说，“也讲讲你自己。” 于是，女孩便开始讲起她和她的父亲。她说她今年21岁，她父亲是一名已退休的政府的物理学家，他们住在第2040号大街的一套小公寓里，自从她母亲四年前去世后，便由她一个人来照顾父亲。 接着马克也给她讲起了他自己以及安妮和杰夫——包括他准备在将来使杰夫成为自己的合伙人；以及安妮对照相机的恐惧症，例如在他们结婚的那天，安妮便拒绝照相并且自那以后，一直也不肯照相；还有他们三个去年夏天野营旅途中的快乐时光。 当马克讲完后，女孩不禁赞叹道：“多么令人愉快的家庭生活啊。生活在1961年定是非常美妙。” “有了时间机器，你随时都可以搬来这里住啊。” “并非那么简单，除了要照顾我父亲外——我无论如何也不会抛弃他的，还有时空警察必须加以考虑。你要知道，时空旅行实际上是仅限于政府发起的历史探险队成员的，它并不向一般公众开放。” “但你似乎来去自如啊。” “那是因为我父亲他自己发明了一台时间机器，而时空警察并不知道。” “但你还是违反了法律呀。” 女孩点点头：“是的，但这仅仅是在他们眼里违法，仅仅是依据他们的时空观念，我父亲他有自己的看法。” 聆听女孩说话是如此的愉快，以至于并不用考虑她讲的是什么内容，马克非常希望女孩继续讲下去，不管她讲的话题在他听来是多么的牵强。 “给我讲讲你父亲的看法吧。”马克赶紧说道。 “首先我要告诉你官方意见。那些认可它的人们认为，未来的人不应实际参与到过去所发生的事情里，因为他们的出现很可能造成某种矛盾，而未来的事件则有可能因为这些矛盾而需发生改变。因此，时空旅行部门规定只有经过授权的人员才有权利使用他们的时间机器，并且组织了专门的警察部门来抓捕那些试图跨越年代的人，如那些向往更简单生活的人，还有那些将自己伪装作历史学家以便永久地回到另一个时代的人。” “但在我父亲看来，时间这本书早已写成。我父亲说，从宏观世界的角度来看，即将发生的每件事情其实已经发生了。因此，如果未来世界的某个人参与了过去的某个事件，那他也就成为了这个事件的一部分——这是因为他原本就是该事件的一部分——因此矛盾也就不可能产生。” 马克深吸了一口烟，郑重地说道：“你父亲是一个非同寻常的人。” “哦，是的。”兴奋使女孩的脸颊显得愈发绯红，她那蓝色的双眸更亮了。 “你肯定不会相信他读过那么多的书，伦道夫先生。啊，我们住的公寓都被他的书给挤满了！黑格尔的，康德的，休姆的，爱因斯坦的，牛顿的，等等等等。我也——我自己也读过其中的一些。” “我收集的同样多，事实上，我也读过其中一些。” 女孩全神贯注地看着马克的脸。“太棒了，伦道夫先生，”她高兴地说，“我敢打赌我们俩拥有许多相同的爱好。” 两人后面的谈话最终证明了他们俩确实有许多相同的爱好——尽管先验主义、贝克莱主义以及相对论并非适合一个男人和一个女孩在九月的小山顶上谈论的话题，尤其是这个男人已经四十四岁了，这个女孩才二十一岁，而马克直到刚才才意识到这一点，不过幸运的是补偿还在后面——两人关于先验主义的愉快讨论不仅引出了“较早”和“较晚”的结论，也引出了女孩眼中那微妙的火花；两人对贝克莱主义的批判不仅强调了这位虔诚的主教的理论中所固有的内在缺陷，也使得女孩的脸更红了；而两人对相对论的回顾则不仅证明了能量确实总是等于质量乘以光速的平方，而且还证明了知识非但不是一种障碍，它还是吸引女性的财富。 那天下午的感觉令马克久久难以忘怀，直到他上床后仍是念念不忘。这一次他不再试图想起安妮，而是躺在黑暗中，任由各种想法不断地向自己涌来——而这些想法都是有关于一个有着蒲公英般色泽长发的女孩。 前天我看见了一只兔子，昨天看见了一头鹿，今天则遇见了你。 第三天早上马克开车前往附近的那个村落，去邮局查看是否有他的信件，结果一封也没有，这并不出乎他的意料。杰夫跟他一样都不爱写信，而安妮此时此刻则很可能是被禁止写信的。至于律师事务所方面，他已要求秘书不得打扰他，除非是极其重要的事情。马克犹豫着是否要向枯瘦的邮局女局长打听这里是否住着姓丹弗斯的人家，最终他还是放弃了，因为这样做便会破坏朱莉所精心虚构的故事，虽然他并不相信这一故事的真实性，但他却不想将这美妙的故事破坏掉。 那天下午，女孩穿着一条黄色的连衣裙并系着一条同头发颜色相同的发带。当马克看到女孩时，他的喉咙又一次紧绷起来，连话都说不出来。但这种感觉很快便消失了，两人的思想如同两条兴奋的小溪一样汇流在一起，欢快地流过下午那段短暂的时光。当他们分手时，女孩问道：“明天你还会来吗？” 这还是女孩第一次这么问——或许这仅仅是女孩从马克的嘴边偷出的问题而已。但这句话却在马克的耳边不断萦绕，一直伴着他走回小屋，直至其恬然入睡。 第四天下午，当马克爬上山顶时，女孩并不在。失望之情淹没了马克，但只一会他便想到，女孩可能是迟到了，或许她立马就要来了。于是马克便坐在那些花岗岩上等待女孩。但女孩并没有来，几分钟过去了——几个小时过去了，女孩还是没有来。阴影从树林中蔓延出来爬上了半山腰，太阳就快下山了，而天气也变得更冷了，马克最终还是放弃了等待，悲伤地走回小屋。第五天下午，女孩还是没有出现。第六天也是。马克吃不下也睡不着，对钓鱼也失去了兴趣，书更是读不进去。自始至终，他都在恨自己——恨自己就像个害相思病的小男生，恨自己就像其他40岁的傻瓜一样对一张漂亮的脸蛋和一对修长的大腿起了那么大的反应。就在不久前，除了安妮外，他还从未如此关注过另外一个女人，然而现在就在这里，在短短不到一个礼拜的时间里，他不仅关注甚至还爱上了那个女人。 第七天下午，在马克爬上山顶前，他已经不抱希望了… 但突然这希望之火又重新点燃了，因为女孩就站在阳光下的山顶上，这次她穿着一条黑色的连衣裙。马克本应在猜测为何她这几天没来，然而他并没有——直到他走近女孩，他才发现女孩流着泪，嘴唇不断地颤抖。 “发生什么事了，朱莉！？” 女孩一把抱住了马克，她的肩膀不断颤抖，她将脸紧紧地贴在马克的外套上。 “我父亲死了，”她痛苦地说。 不知为何，马克知道这是女孩第一次流泪。在葬礼和守丧的整个过程，女孩一滴眼泪也没流过，直到现在崩溃为止。 马克轻轻地抱住女孩。在这之前他从未吻过她，现在他也没有，但或许也不能这么说。因为他的嘴唇掠过了女孩的前额，轻轻地吻了她的长发——仅此而已。 “我很遗憾，朱莉，”马克说，“我知道你父亲对你意味着什么。” “他早就知道自己快要死了，” “从他在实验室里做锶90的实验时起他肯定便知道了。但他没有告诉任何人——他甚至没有告诉我…我也不想活了。没有了他我活着还有什么意义！没有任何的意义了！” 马克紧紧地抱住女孩：“不，朱莉，还有一些东西值得你活着，或许是某个人。你还年轻，你还不过是个孩子。” 女孩的脸猛地往后一仰，她的双眼突然之间眼泪全无，并紧紧地盯着马克的眼睛：“我不是个孩子，你竟敢称我为孩子！” 一惊之下，马克放开了女孩，往后退了几步。他还从未见过女孩生气的样子，“我不是这个意思…” 女孩的气来得快，去得也快。“我知道你不是有意要伤我的心，伦道夫先生，但我不是个孩子，真的不是，请答应我，以后别再叫我孩子了，好吗？” “好的，”马克忙说，“我答应你。” “现在我得走了，”女孩说，“还有一大堆的事等着我去做呢。” “明天…明天你还会来吗？” 女孩久久地注视着马克。一阵薄雾——那是夏季雨后的产物，令她那蓝色的双眸更加闪亮。 “时间机器出了些问题，”她说，“有些零件需要更换…但我不知道要如何更换。它可能只能再做一次旅行了，我并不能确定。” “但你还是会设法来的，对吧？” 女孩点点头：“是的，我会。还有…先生…” “怎么了，朱莉？” “万一我没法来的话…请记住——我爱你。” 女孩走了，她轻巧地跑下山，不一会儿便消失在那片糖枫林里。马克想点烟斗，但他的手却不断颤抖，划开的火柴烧着了他的手。马克已经完全不记得他是如何回到小屋，如何做的晚饭，如何上的床，但他确实做了这些，因为当他醒来时，他就躺在卧室里，而当他走进厨房时，那些用过的餐具则躺在洗碗池里。马克将碗洗好并煮了咖啡。一个早上他都在桥墩上钓鱼，以保持脑子里面一片空白。他想过会儿再面对现实，他的脑子里都是有关于女孩向他表白的事。再过几个小时就能见面了——当然即使那“时间机器”出了问题也完全能将女孩从“未来”带到山上的。 马克提早到了山上，他坐在那些花岗岩上等待女孩。他感觉到自己的心脏正在“砰砰砰”地乱跳，而他的手则在不断颤抖。 前天我看见了一只兔子，昨天看见了一头鹿，今天则遇见了你。 马克等啊等，等啊等，可女孩没有来。隔天她还是没有来。当影子变得更长而天气更冷时，马克爬下山，走进了那片糖枫林。不久，他便找着一条小路，沿着那条小路，马克穿过树林到达了那个小村落，他在邮局前停了下来，查看是否有自己的信件。那位枯瘦的女局长告诉他没有寄给他的信，马克在那里踌躇了一会后，突然问道：“是否有户姓丹弗斯的人家住在这附近呢？” 女局长摇了摇头：“从没听说过啊。” “那么最近这镇里举行过葬礼吗？” “那至少是一年前的事了。” 至那以后，尽管每天下午马克都去那座小山，但直到假期结束，女孩都未再出现过，马克心里知道女孩再也不会回来了，她已经不再属于他，完完全全，彻彻底底的，就像她从未属于过他一样。夜晚，马克常游荡于那个小村落，他近乎绝望地认为或许是那个女局长搞错了啊，但他并未找到朱莉存在的任何迹象，而他向过往的人描述女孩的形象得到的却仅仅是否定的回答。十月初，马克回到城里，他在安妮面前尽力表现以表明他们俩之间一切如初，但安妮却似乎在看到他的第一眼时便察觉到了某种不同。尽管她什么也没有问，但随着时间的推移，她却变得越来越沉默，而她眼中那曾经使马克疑惑不已的恐惧感也变得越来越明显了。每个礼拜天的下午马克便会开车前往那座小山，那片树林现在已变得金黄，而天空则变得比一个月前还要蓝。马克在那块花岗岩上一坐便是几个小时，凝视着女孩消失的那个地方。 前天我看见了一只兔子，昨天看见了一头鹿，今天则遇见了你。 在十一月中旬的一个下雨的夜晚，马克发现了一个手提箱。这是安妮的手提箱，马克也是很偶然才发现的。安妮去城里打牌，而他则一个人呆在家里，在花了两个小时观看无聊的电视后，马克突然想起去年冬天自己收藏的一些拼图游戏。为了寻找一些东西——任何东西——以使自己忘记朱莉，马克爬上了阁楼，去寻找那些拼图游戏。当他翻箱倒柜地寻找时，那个手提箱从一个架子上掉了下来，撞在地板上，自己打开了——可能是触动了弹簧。马克弯腰捡起了它，这是他们俩结婚后租在一个小公寓时，安妮所携带的那个手提箱。马克还记得安妮总是锁着它，并笑着对他说这里面放着一些秘密，这些秘密即使是对老公也要保密。箱子的锁经过这么多年早已生锈，而刚才的那下撞击则使它彻底坏掉。 马克准备把箱子合上，忽然他看到了一条白色连衣裙的摺边，他停住了。那是一种似曾相识的料子，他曾经在不久之前见过类似的料子——那种由棉花糖、海水泡沫以及雪花混合而成的料子。马克抬起箱盖，用他那颤抖的手指拾起那条连衣裙。他的手抓住连衣裙的两肩，让它自个展开，裙子悬在半空就像轻轻下落的雪花。马克盯着裙子一动也不动，他的喉咙绷紧了。过了好久之后，马克轻轻地将裙子叠好，将它放回箱里，并把箱子合上。他将箱子放回了原处。 连衣裙上附有一张纸条，上面写着： 前天我看见了一只兔子，昨天看见了一头鹿，今天则遇见了你。 雨点敲打着房顶，马克的喉咙愈发绷紧了，以至于有段时间马克都想喊出声来了。过了一会儿，马克慢慢地从阁楼上走了下来，他沿着盘旋的楼梯走进了起居室，壁炉上的时钟显示现在已经是22点14分了，再过几分钟，公车便会载着安妮在街角停下，安妮下车后将沿着人行道走到前门。安妮？朱莉？朱莉安妮？那是她的全名吗？或许是的，人们在使用别名时总会保留自己原名的一部分。在完全更改了自己的姓氏后，她或许认为保留自己的名字是安全的，除了改姓氏外，她必定还做过其他的一些事以躲避那些时空警察。而她不愿意照相的事现在看来也不足为奇了。现在想来，当时羞涩地走入自己的办公室谋求一份工作的她，该是多么诚惶诚恐啊。孤身一人在一个陌生的年代，既不确定父亲关于时空的观点是否正确，也不确定那个会在40岁时爱上她的男人在20岁时是否对她也有同样的感觉。但她还是来了，就像她说的那样。 二十年了，她一直都知道有一天我将会爬上一座小山并看见年轻而又可爱的她站在阳光下，知道我会再一次地爱上她。她一定知道这些，因为这些作为我未来人生的一部分也正是她过去的一部分。但是她为何不提前告诉我呢？为什么她到现在也还不告诉我呢？ 马克不断地思考着。忽然，他明白了。马克觉得自己快要窒息了，他跑进门厅，穿上雨衣，出了门，快步朝雨中走去，他沿着人行道走着，雨点打在他的脸上，并沿着他的脸颊滑落下来，其中有一些是雨水，而还有一些则是泪水。 一个人若拥有像安妮或者说朱莉那样的不老容颜，该多么惧怕变老啊。可是她难道不知道在我眼里，其实她一点也没变老？对于我而言，从在办公室里见到她并爱上她的那时起，她就一天也未老过。难道她不明白这就是为什么山上的那个女孩对我而言，就如同一个陌生人一样的原因？ 马克朝着街角的方向走去，当他快到时，公车也开到了。穿着白色防水大衣的安妮从车上走下。马克的喉咙绷得使他无法呼吸。那蒲公英色泽的长发现在颜色更深了，而那种少女所特有的魅力已经不再，但那温柔的可爱却仍驻留在她那文雅的脸上，那修长而又苗条的双腿在十一月的街灯下显得如此地优美、匀称，就如同在九月阳光照耀下的那双长腿一般。 安妮朝马克走来，她的眼中有着马克所熟悉的那种恐惧——而此时，那种恐惧更甚以往——马克知道那是为何。马克的视线模糊了，他盲目地朝着安妮走去，当他走近时，他的眼睛亮了起来，他的手穿越过岁月，触摸在安妮那被雨打湿的脸颊上，安妮很快便明白了一切，她眼中的恐惧永远地消失了。 他们俩手牵手一起朝家里走去…","keywords":null},{"title":"book-list","date":"2018-12-20T15:13:05.000Z","updated":"2023-03-13T17:44:05.461Z","comments":false,"path":"tags/悦读/index.html","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/tags/悦读/index.html","excerpt":"","text":"蒲公英女孩","keywords":null}],"posts":[{"title":"嘴巴开省选","slug":"嘴巴开省选","date":"2023-03-04T16:05:46.000Z","updated":"2023-03-19T11:31:18.276Z","comments":false,"path":"2023/03/05/嘴巴开省选/","link":"","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/2023/03/05/嘴巴开省选/","excerpt":"","text":"pbds namespace\\text{namespace}namespace 是 __gnu_pbds，头文件可以直接 #include&lt;bits/extc++.h&gt; ，不过 devcpp 用不了，只能 #include&lt;ext/pb_ds/assoc_container.hpp&gt; 以及对应的头文件，迭代器都是 point_iterator\\text{point\\_iterator}point_iterator。 哈希表 根据别人以及自己的 benchmark\\text{benchmark}benchmark 来说 hash_table\\text{hash\\_table}hash_table 表现很优秀，非构造数据卡点常还是要写的。 头文件： #include&lt;ext/pb_ds/hash_policy.h&gt; 声明：gp_hash_table&lt;int,int&gt;，当 unordered_set\\text{unordered\\_set}unordered_set 用的话是 gp_hash_table&lt;int,nulltype&gt; 使用：同 unordered_map\\text{unordered\\_map}unordered_map ，直接遍历也是 O(n)O(n)O(n) 乱序的。 堆 用配对堆，支持 O(1) push joinO(1)\\ \\text{push join}O(1) push join，O(log⁡) erase modifyO(\\log)\\ \\text{erase modify}O(log) erase modify 。 头文件： #include&lt;ext/pb_ds/priority_queue.h&gt; 声明：__gnu_pbds::priority_queue&lt;int,greater&lt;int&gt;,pairing_heap_tag&gt; 使用：push\\text{push}push 会返回迭代器，join\\text{join}join 为 a.join(b)\\text{a.join(b)}a.join(b) 且清空 b\\text bb ，erase\\text{erase}erase 为 q.erase(it)\\text{q.erase(it)}q.erase(it)，modify\\text{modify}modify 为 q.modify(it,x)\\text{q.modify(it,x)}q.modify(it,x) ，当 it\\text{it}it 为 NULL\\text{NULL}NULL 时就不在堆中，自定义比较同标准库要用 struct\\text{struct}struct 。 平衡树 用红黑树，相比 set\\text{set}set 支持 kth rank join split\\text{kth rank join split}kth rank join split ，和 fhq_treap\\text{fhq\\_treap}fhq_treap 的常数差不多，常数较大。 头文件： #include&lt;ext/pb_ds/tree_policy.h&gt; 声明：tree&lt;int,null_type,less&lt;int&gt;,rb_tree_tag,tree_order_statistics_node_update&gt; 使用：同 set\\text{set}set ，实现 multiset\\text{multiset}multiset 要用 pair\\text{pair}pair 通过第二关键字区分，下标从 000 开始，kth\\text{kth}kth 是 *t.find_by_order(k-1)\\text{*t.find\\_by\\_order(k-1)}*t.find_by_order(k-1) ，求排名是 t.order_of_key(x)+1\\text{t.order\\_of\\_key(x)+1}t.order_of_key(x)+1 ，合并是 a.join(b)\\text{a.join(b)}a.join(b) 且清空 b\\text bb ，要保证两树值域不交，分裂是 a.split(x,b)\\text{a.split(x,b)}a.split(x,b) 把 b\\text bb 清空再把 &gt;x&gt;x&gt;x 的元素分给 b\\text bb 。 拉格朗日插值 推法 1 ∵f(x)−f(y)=(a0−a0)+a1(x−y)+a2(x2−y2)+...+an(xn−yn)\\because f(x)-f(y)=(a_0-a_0)+a_1(x-y)+a_2(x^2-y^2)+...+a_n(x^n-y^n)∵f(x)−f(y)=(a0​−a0​)+a1​(x−y)+a2​(x2−y2)+...+an​(xn−yn) ∴f(x)≡f(y)(modx−y)\\therefore f(x)\\equiv f(y)\\pmod {x-y}∴f(x)≡f(y)(modx−y) 现在要对 nnn 个点值 (xi,yi)(x_i,y_i)(xi​,yi​) 进行插值，根据前面的证明可以转化得到线性同余方程组 {f(x)≡y1(modx−x1))f(x)≡y2(modx−x2))...\\left\\{\\begin{matrix}f(x)\\equiv y_1\\pmod {x-x_1})\\\\ f(x)\\equiv y_2\\pmod {x-x_2})\\\\ ...\\end{matrix}\\right.⎩⎨⎧​f(x)≡y1​(modx−x1​))f(x)≡y2​(modx−x2​))...​ 用 CRT\\text{CRT}CRT 合并：M=∏(x−xi),mi=Mx−xi,mi−1=∏j≠ixi−xjM=\\prod (x-x_i),m_i=\\frac M {x-x_i},m_i^{-1}=\\prod_{j\\ne i}x_i-x_jM=∏(x−xi​),mi​=x−xi​M​,mi−1​=∏j=i​xi​−xj​ ⇒f(x)≡∑yimimi−1≡∑yi∏j≠ix−xjxi−xj(modM)\\Rightarrow f(x)\\equiv \\sum y_im_im_i^{-1}\\equiv \\sum y_i\\prod_{j\\ne i}\\frac {x-x_j} {x_i-x_j}\\pmod M⇒f(x)≡∑yi​mi​mi−1​≡∑yi​∏j=i​xi​−xj​x−xj​​(modM) 由于 MMM 的次数更高所以直接略去，就得到了拉格朗日插值的式子。 推法 2 有代数基本定理：nnn 个不同点值能在 n−1n-1n−1 次以内确定唯一的一个多项式。所以构造出一个满足这 nnn 个点值的不超过 n−1n-1n−1 的多项式那他就是唯一确定的。 考虑对于每一个点值构造一个不超过 n−1n-1n−1 次的多项式 fif_ifi​ 满足 fi(xi)=yi,fi(xj[j≠i])=0f_i(x_i)=y_i,f_i(x_{j[j\\ne i]})=0fi​(xi​)=yi​,fi​(xj[j=i]​)=0 ，那么 f(x)=∑fi(x)f(x)=\\sum f_i(x)f(x)=∑fi​(x)。 根据 fi(xj[j≠i])=0f_i(x_{j[j\\ne i]})=0fi​(xj[j=i]​)=0 很容易构造出 fi(x)=(?)∏j≠i(x−xi)f_i(x)=(?)\\prod_{j\\ne i}(x-x_i)fi​(x)=(?)∏j=i​(x−xi​) ，再代入 fi(xi)=yif_i(x_i)=y_ifi​(xi​)=yi​ 就可以解得 fi(x)=yi∏j≠ix−xjxi−xjf_i(x)=y_i\\prod_{j\\ne i}\\frac {x-x_j} {x_i-x_j}fi​(x)=yi​∏j=i​xi​−xj​x−xj​​，求和就得到了拉格朗日插值的式子。 应用 直接代入式子可以 O(n2)O(n^2)O(n2) 插值。 int F(int x) { int sum=0; for(rint i=1;i&lt;=n;i++) { int res=Y[i],inv=1; for(rint j=1;j&lt;=n;j++) if(j!=i) res=res*(x-X[j]+p)%p,inv=inv*(X[i]-X[j]+p)%p; sum=(sum+res*qp(inv))%p; } return sum; } 若插值使用的是连续一段整数的话，∏i≠jx−ji−j=(x−1)n‾(−1)n−i(x−i)(i−1)!(n−i)!\\prod_{i\\ne j}\\frac{x-j}{i-j}=\\frac {(x-1)^{\\underline n}(-1)^{n-i}} {(x-i)(i-1)!(n-i)!}∏i=j​i−jx−j​=(x−i)(i−1)!(n−i)!(x−1)n​(−1)n−i​，避免除 000 维护前后缀积就可以 O(n)O(n)O(n) 求值了。 int F(int x) { int sum=0;suf[n+1]=1; for(rint i=n;i;i--) suf[i]=suf[i+1]*(x-i+p)%p; for(rint i=1,pre=1;i&lt;=n;i++) { int mul=Y[i]*pre%p*suf[i+1]%p,inv=fac[i-1]*fac[n-i]%p*((n-i)&amp;1?p-1:1)%p; sum=(sum+mul*qp(inv))%p,pre=pre*(x-i+p)%p; } return sum; } 引理：若一个 kkk 次多项式满足 F(1,2,...,k)F(1,2,...,k)F(1,2,...,k) 都是整数，那么对于任意整数 xxx ，F(x)F(x)F(x) 都是整数。 证明考虑代入拉插式子即可，所以如果模数非大质数的话是可以高精度的 ，当然也可以对模数分解质因数分别求解后 CRT\\text{CRT}CRT 合并。 原根 阶 定义：满足 an≡1(modp)a^n\\equiv 1\\pmod pan≡1(modp) 的最小正整数 nnn 即为 aaa 模 ppp 的阶，记为 δp(a)\\delta_p(a)δp​(a)。 存在：当 (a,p)=1(a,p)=1(a,p)=1 时有 aφ(p)≡1(modp)a^{\\varphi(p)}\\equiv1 \\pmod paφ(p)≡1(modp) ，所以 δp(a)≤φ(p)\\delta_p(a)\\le \\varphi(p)δp​(a)≤φ(p)。 性质： a,a2,...,aδp(a)a,a^2,...,a^{\\delta_p(a)}a,a2,...,aδp​(a) 模 ppp 互不同余。 若 an≡1(modp)a^n\\equiv1\\pmod pan≡1(modp)，则 δp(a)∣n\\delta_p(a)|nδp​(a)∣n。 若 (a,p)=(b,p)=1(a,p)=(b,p)=1(a,p)=(b,p)=1，则此时 δp(ab)=δp(a)δp(b)⇔(δp(a),δp(b))=1\\delta_p(ab)=\\delta_p(a)\\delta_p(b)\\Leftrightarrow (\\delta_p(a),\\delta_p(b))=1δp​(ab)=δp​(a)δp​(b)⇔(δp​(a),δp​(b))=1。 若 (a,p)=1(a,p)=1(a,p)=1，则 δp(ak)=δp(a)(δp(a),k)\\delta_p(a^k)=\\frac {\\delta_p(a)} {(\\delta_p(a),k)}δp​(ak)=(δp​(a),k)δp​(a)​。 原根 定义：若 (a,p)=1(a,p)=1(a,p)=1 且 δp(a)=φ(p)\\delta_p(a)=\\varphi(p)δp​(a)=φ(p)，则称 aaa 为模 ppp 的原根。 原根判定定理：若 m≥3m\\ge3m≥3 且 (a,p)=1(a,p)=1(a,p)=1，则 [a 为原根]⇔∀素因子 P∈φ(p),aφ(p)P≢1(modp)[a\\text{ 为原根}]\\Leftrightarrow \\forall \\text{素因子 }P\\in \\varphi(p),a^{\\frac {\\varphi(p)} P}\\not\\equiv1\\pmod p[a 为原根]⇔∀素因子 P∈φ(p),aPφ(p)​≡1(modp)。 原根个数：若 ppp 有原根，则原根数量为 φ(φ(p))\\varphi(\\varphi(p))φ(φ(p))，证明考虑任意原根 === 最小原根k^kk 且 (k,φ(p))=1(k,\\varphi(p))=1(k,φ(p))=1。 原根大小：若 ppp 有原根，则最小原根 ≤p4\\le\\sqrt[4] p≤4p​ ，故暴力找原根的复杂度为 O(p4log⁡)O(\\sqrt[4] p\\log)O(4p​log)。 原根存在定理：ppp 有原根 ⇔\\Leftrightarrow⇔ p=2,4,Pk,2Pkp=2,4,P^k,2P^kp=2,4,Pk,2Pk，PPP 为奇素数。 BSGS 应用 O(p)O(\\sqrt p)O(p​) 求解满足 ax≡b(modp)a^x\\equiv b\\pmod pax≡b(modp) 或 xa≡b(modp)x^a\\equiv b\\pmod pxa≡b(modp) 的最小 xxx ，即求模意义下的对数或底数。 一般BSGS a⊥pa\\perp pa⊥p，即 a pa\\ pa p 要互质，保证有逆元。 将 xxx 表示为 A⌊p⌋−B (A,B&lt;p)⇒aA⌊p⌋≡baBA\\left \\lfloor \\sqrt p \\right \\rfloor -B\\ \\ (A,B&lt;\\sqrt p)\\Rightarrow a^{A\\left \\lfloor \\sqrt p \\right \\rfloor}\\equiv ba^BA⌊p​⌋−B (A,B&lt;p​)⇒aA⌊p​⌋≡baB 用哈希表映射 baB⇒Bba^B\\Rightarrow BbaB⇒B，O(p)O(\\sqrt p)O(p​) 枚举 AAA，若能查到对应 BBB 即得答案。 gp_hash_table&lt;int,int&gt; mp; int bsgs(int x,int y) { int sq=ceil(sqrt(p));mp.clear(); for(rint now=1,i=0;i&lt;=sq;i++,now=now*x%p) mp[y*now%p]=i; gp_hash_table&lt;int,int&gt;::point_iterator it; for(rint i=0,now=1,res=qp(x,sq);i&lt;=sq;i++,now=now*res%p) if((it=mp.find(now))!=mp.end()&amp;&amp;i*sq&gt;=it-&gt;second) return i*sq-it-&gt;second; return -1; } exBSGS ppp 可为任意模数。 先特判 b=1b=1b=1 和 p=1p=1p=1 的情况。 利用模的分配率⇒ak∏kgiax−k≡b∏kgi(modp∏kgi)\\Rightarrow \\frac {a^k} {\\prod^k g_i} a^{x-k}\\equiv \\frac b {\\prod^k g_i}\\pmod {\\frac p {\\prod^k g_i}}⇒∏kgi​ak​ax−k≡∏kgi​b​(mod∏kgi​p​) 满足 (a,p∏kgi)=1(a,\\frac p {\\prod^k g_i})=1(a,∏kgi​p​)=1，若 ∏kgi∤b\\prod^k g_i\\nmid b∏kgi​∤b 则无解，证明考虑 (ag)xgx+pgg=b(\\frac a g)^xg^x+\\frac p gg=b(ga​)xgx+gp​g=b 中 bbb 一定含有因子 ggg。 ⇒ax−k≡bak∏kgi∏kgi(modp∏kgi)\\Rightarrow a^{x-k}\\equiv \\frac b {\\frac {a^k} {\\prod^k g_i}\\prod^k g_i}\\pmod {\\frac p {\\prod^kg_i}}⇒ax−k≡∏kgi​ak​∏kgi​b​(mod∏kgi​p​) ，此时满足互质，BSGS\\text{BSGS}BSGS 求出 x−kx-kx−k 即可。 int exbsgs(int x,int y) { if(p==1||y==1) return 0; int g=__gcd(x,p),k=0,sum=1; while(g!=1) { if(y%g) return -1; k++,y/=g,p/=g,sum=sum*(x/g)%p; if(sum==y) return k; //特判x==k g=__gcd(x,p); } int ans=bsgs(x,y*inv(sum)%p); if(~ans) return ans+k; return -1; } 求底数 求 xa≡b(modp)x^a\\equiv b\\pmod pxa≡b(modp) 要满足 ppp 为质数，保证 ppp 有原根且能使用 BSGS\\text{BSGS}BSGS。 设 ggg 为 ppp 的原根，则 x=gyx=g^yx=gy，(ga)y≡b(modp)(g^a)^y\\equiv b\\pmod p(ga)y≡b(modp)，BSGS\\text{BSGS}BSGS 求解即可。 积性函数 定义 数论函数：f:Z+→Cf:Z^+\\rightarrow Cf:Z+→C，即定义域为正整数，值域为复数的函数。 积性函数：满足 f(1)=1f(1)=1f(1)=1 且 f(p×q)=f(p)×f(q) (p,q)=1f(p\\times q)=f(p)\\times f(q)\\ \\ (p,q)=1f(p×q)=f(p)×f(q) (p,q)=1 的函数。 完全积性函数：满足 f(1)=1f(1)=1f(1)=1 且 f(p×q)=f(p)×f(q) p,q∈Z+f(p\\times q)=f(p)\\times f(q)\\ \\ p,q\\in Z^+f(p×q)=f(p)×f(q) p,q∈Z+ 的函数。 常见完全积性函数 元函数：e(n)=[n=1]e(n)=[n=1]e(n)=[n=1] 恒等函数：I(n)=1I(n)=1I(n)=1 单位函数：id(n)=nid(n)=nid(n)=n 幂函数：idk(n)=nkid^k(n)=n^kidk(n)=nk 常见积性函数 约数个数函数：τ(n)=d(n)=σ0(n)=∑d∣n1\\tau(n)=d(n)=\\sigma_0(n)=\\sum_{d|n}1τ(n)=d(n)=σ0​(n)=∑d∣n​1 约数和函数：σ(n)=σ1(n)=∑d∣nd\\sigma(n)=\\sigma_1(n)=\\sum_{d|n}dσ(n)=σ1​(n)=∑d∣n​d 除数函数：σk(n)=∑d∣ndk\\sigma_k(n)=\\sum_{d|n}d^kσk​(n)=∑d∣n​dk，即约数 kkk 次幂和。 欧拉函数：φ(n)=∑i=1n[(i,n)=1]\\varphi(n)=\\sum_{i=1}^n[(i,n)=1]φ(n)=∑i=1n​[(i,n)=1]，即 1∼n1\\sim n1∼n 与 nnn 互质的个数。 φ(p)=p−1,p∈prime\\varphi(p)=p-1,p\\in primeφ(p)=p−1,p∈prime。 ∑(i,n)=1ni=nφ(n)+[n=1]2\\sum^n_{(i,n)=1}i=\\frac {n\\varphi(n)+[n=1]} 2∑(i,n)=1n​i=2nφ(n)+[n=1]​。 若 n&gt;2n&gt;2n&gt;2，则 φ(n)\\varphi(n)φ(n) 为偶数。 莫比乌斯函数：μ(n)={0∃ ci&gt;1(−1)k∀ ci=1\\mu(n)=\\left\\{\\begin{matrix}0 &amp;\\exist \\ c_i&gt;1 \\\\(-1)^k &amp; \\forall \\ c_i=1\\end{matrix}\\right.μ(n)={0(−1)k​∃ ci​&gt;1∀ ci​=1​ ，n=∏kpicin=\\prod^kp_i^{c_i}n=∏kpici​​ 狄利克雷卷积 定义 数论函数 fff 与 ggg 的狄利克雷卷积 (f∗g)(n)=∑d∣nf(d)g(nd)(f*g)(n)=\\sum_{d|n}f(d)g(\\frac n d)(f∗g)(n)=∑d∣n​f(d)g(dn​)。 性质 满足交换律、结合律、分配律，若 f,gf,gf,g 均积性，则 f∗gf*gf∗g 也为积性。 对于元函数：f∗e=ff*e=ff∗e=f，eee 即为单位元。 对于积性函数 fff：f∗I=∏i=1k∑j=0cif(pij)f*I=\\prod^k_{i=1}\\sum_{j=0}^{c_i}f(p_i^j)f∗I=∏i=1k​∑j=0ci​​f(pij​)，考虑分解质因数得证。 对于莫比乌斯函数：μ∗I=∑d∣nμ(d)=∑i=0k(ki)(−1)i=(1−1)k=e\\mu*I=\\sum_{d|n}\\mu(d)=\\sum_{i=0}^k\\binom k i(-1)^i=(1-1)^k=eμ∗I=∑d∣n​μ(d)=∑i=0k​(ik​)(−1)i=(1−1)k=e，考虑定义得证，发现 f∗I∗μ=ff*I*\\mu=ff∗I∗μ=f，称为莫比乌斯反演。 对于欧拉函数：φ(n)=∑i=1ne((i,n))=∑i=1nμ∗I((i,n))=∑i=1n∑d∣(i,n)μ(d)=\\varphi(n)=\\sum_{i=1}^ne((i,n))=\\sum_{i=1}^n\\mu*I((i,n))=\\sum_{i=1}^n\\sum_{d|(i,n)}\\mu(d)=φ(n)=∑i=1n​e((i,n))=∑i=1n​μ∗I((i,n))=∑i=1n​∑d∣(i,n)​μ(d)=∑d=1nμ(d)∑i[d∣(i,n)]=∑d=1nμ(d)⌊nd⌋=μ∗id\\sum_{d=1}^n\\mu(d)\\sum_i[d|(i,n)]=\\sum_{d=1}^n\\mu(d)\\left \\lfloor \\frac n d \\right \\rfloor=\\mu*id∑d=1n​μ(d)∑i​[d∣(i,n)]=∑d=1n​μ(d)⌊dn​⌋=μ∗id，φ=μ∗id⇔φ∗I=id\\varphi=\\mu*id\\Leftrightarrow\\varphi*I=idφ=μ∗id⇔φ∗I=id，称为欧拉反演，本质同莫反。 对于约数函数：τ=I∗I\\tau=I*Iτ=I∗I，σ=I∗id\\sigma=I*idσ=I∗id，σk=I∗idk\\sigma_k=I*id^kσk​=I∗idk，考虑定义得证。 另外 τ(ij)=∑x∣i∑y∣j[(x,y)=1]\\tau(ij)=\\sum_{x|i}\\sum_{y|j}[(x,y)=1]τ(ij)=∑x∣i​∑y∣j​[(x,y)=1]，证明考虑拆位，每种质因数的方案贡献一定是 a+b+1a+b+1a+b+1，保证 gcd⁡=1\\gcd=1gcd=1 时的方案贡献也为 a+b+1a+b+1a+b+1，所以是等价的。 还有其扩展，τ(ABC)=∑x∣A∑y∣B∑z∣C[(x,y)=1][(x,z)=1][(y,z)=1]\\tau(ABC)=\\sum_{x|A}\\sum_{y|B}\\sum_{z|C}[(x,y)=1][(x,z)=1][(y,z)=1]τ(ABC)=∑x∣A​∑y∣B​∑z∣C​[(x,y)=1][(x,z)=1][(y,z)=1] σk(AB)=∑x∣A∑y∣B[(x,By)=1](xy)k\\sigma_k(AB)=\\sum_{x|A}\\sum_{y|B}[(x,\\frac B y)=1](xy)^kσk​(AB)=∑x∣A​∑y∣B​[(x,yB​)=1](xy)k σk(ABC)=∑x∣A∑y∣B∑z∣C[(x,By)=1][(y,Cz)=1][(x,Cz)=1](xyz)k\\sigma_k(ABC)=\\sum_{x|A}\\sum_{y|B}\\sum_{z|C}[(x,\\frac B y)=1][(y,\\frac C z)=1][(x,\\frac C z)=1](xyz)^kσk​(ABC)=∑x∣A​∑y∣B​∑z∣C​[(x,yB​)=1][(y,zC​)=1][(x,zC​)=1](xyz)k 证明思路基本相同。 对于约数和函数：σ=id∗I∗e=id∗I∗I∗μ=τ∗φ\\sigma=id*I*e=id*I*I*\\mu=\\tau*\\varphiσ=id∗I∗e=id∗I∗I∗μ=τ∗φ 。 对于 gcd⁡\\gcdgcd ：∑in∑jngcd⁡(i,j)=∑d=1nd∑in∑jn[(i,j)=d]=∑d=1nd∑in/d∑jn/de((i,j))=\\sum_i^n\\sum_j^n\\gcd(i,j)=\\sum^n_{d=1}d\\sum_i^n\\sum_j^n[(i,j)=d]=\\sum^n_{d=1}d\\sum_i^{n/d}\\sum_j^{n/d}e((i,j))=∑in​∑jn​gcd(i,j)=∑d=1n​d∑in​∑jn​[(i,j)=d]=∑d=1n​d∑in/d​∑jn/d​e((i,j))=∑d=1nd∑in/d∑jn/d∑q∣(i,j)μ(q)=∑d=1nd∑q=1n/dμ(q)⌊ndq⌋2=∑t=1n⌊nt⌋2∑d∣td×μ(td)\\sum^n_{d=1}d\\sum_i^{n/d}\\sum_j^{n/d}\\sum_{q|(i,j)}\\mu(q)=\\sum^n_{d=1}d\\sum_{q=1}^{n/d}\\mu(q)\\left \\lfloor \\frac n {dq} \\right \\rfloor^2=\\sum^n_{t=1}\\left \\lfloor \\frac n t \\right \\rfloor^2\\sum_{d|t}d\\times\\mu(\\frac t d)∑d=1n​d∑in/d​∑jn/d​∑q∣(i,j)​μ(q)=∑d=1n​d∑q=1n/d​μ(q)⌊dqn​⌋2=∑t=1n​⌊tn​⌋2∑d∣t​d×μ(dt​) 对于完全积性函数 hhh：f(n)=∑i=1nh(i)g(⌊ni⌋)⇔g(n)=∑i=1nμ(i)h(i)f(⌊ni⌋)f(n)=\\sum_{i=1}^nh(i)g(\\lfloor\\frac n i \\rfloor)\\Leftrightarrow g(n)=\\sum_{i=1}^n\\mu(i)h(i)f(\\lfloor \\frac n i \\rfloor)f(n)=∑i=1n​h(i)g(⌊in​⌋)⇔g(n)=∑i=1n​μ(i)h(i)f(⌊in​⌋)，f,gf,gf,g 为数论函数，不会证。 方法 val⇒bool×valval\\Rightarrow bool\\times valval⇒bool×val，bool⇒ebool\\Rightarrow ebool⇒e，e⇒μe\\Rightarrow \\mue⇒μ 交换求和顺序。 利用整除分块、积性筛法求解。 杜教筛 定义 在亚线性时间复杂度求解部分数论函数前缀和，一般为 O(n23)O(n^{\\frac 2 3})O(n32​)，常见的判定法是若 A∗B=CA*B=CA∗B=C 中 AAA 可线筛 B CB\\ CB C 可杜教筛，则 AAA 可杜教筛。 要计算 s(n)=∑i=1nf(i)s(n)=\\sum_{i=1}^nf(i)s(n)=∑i=1n​f(i)，考虑任意数论函数 ggg 满足 ∑i=1n(f∗g)(i)=∑i=1n∑d∣if(d)g(id)=∑i=1ng(i)s(⌊ni⌋)\\sum_{i=1}^n(f*g)(i)=\\sum_{i=1}^n\\sum_{d|i}f(d)g(\\frac i d)=\\sum_{i=1}^ng(i)s(\\lfloor \\frac n i \\rfloor)∑i=1n​(f∗g)(i)=∑i=1n​∑d∣i​f(d)g(di​)=∑i=1n​g(i)s(⌊in​⌋)，可以得到 s(n)=∑i=1n(f∗g)(i)−∑i=2ng(i)s(⌊ni⌋)s(n)=\\sum_{i=1}^n(f*g)(i)-\\sum_{i=2}^ng(i)s(\\lfloor \\frac n i\\rfloor)s(n)=∑i=1n​(f∗g)(i)−∑i=2n​g(i)s(⌊in​⌋)，找到合适的 ggg 能快速记忆化递归计算即可。 实例 s(n)=∑i=1nμ(i)s(n)=\\sum_{i=1}^n\\mu(i)s(n)=∑i=1n​μ(i)：取 g=Ig=Ig=I，这样 μ∗I=e\\mu*I=eμ∗I=e，s(n)=1−∑i=2ns(⌊ni⌋)s(n)=1-\\sum_{i=2}^ns(\\lfloor \\frac n i\\rfloor)s(n)=1−∑i=2n​s(⌊in​⌋)，直接记忆化递归是 O(∑i=1nni)=O(n34)O(\\sum_{i=1}^{\\sqrt n}\\sqrt{\\frac n i})=O(n^{\\frac 3 4})O(∑i=1n​​in​​)=O(n43​)，线性筛预处理即为 O(n23)O(n^{\\frac 2 3})O(n32​)，注意记忆化不用 mapmapmap，因为 ⌊⌊nd1⌋d2⌋=⌊nd1d2⌋\\lfloor \\frac {\\lfloor \\frac n {d_1} \\rfloor} {d_2} \\rfloor=\\lfloor \\frac n {d_1d_2}\\rfloor⌊d2​⌊d1​n​⌋​⌋=⌊d1​d2​n​⌋，所以 n13n^{\\frac 1 3}n31​ 长的数组下标直接记录 ddd 即可。 s(n)=∑i=1nφ(i)s(n)=\\sum_{i=1}^n\\varphi(i)s(n)=∑i=1n​φ(i)：取 g=Ig=Ig=I，这样 φ∗I=id\\varphi*I=idφ∗I=id，s(n)=i∗(i+1)2−∑i=2ns(⌊ni⌋)s(n)=\\frac {i*(i+1)} 2-\\sum_{i=2}^ns(\\lfloor \\frac n i\\rfloor)s(n)=2i∗(i+1)​−∑i=2n​s(⌊in​⌋)， O(n23)O(n^{\\frac 2 3})O(n32​) 。 s(n)=∑i=1nφ(i)∗i2s(n)=\\sum_{i=1}^n\\varphi(i)*i^2s(n)=∑i=1n​φ(i)∗i2：取 g=id2g=id^2g=id2，这样 (φ id2)∗(id2)=id3(\\varphi\\ id^2)*(id^2)=id^3(φ id2)∗(id2)=id3，s(n)=(n(n+1)2)2−∑i=2ni2s(⌊ni⌋)s(n)=(\\frac {n(n+1)} 2)^2-\\sum_{i=2}^ni^2s(\\lfloor \\frac n i\\rfloor)s(n)=(2n(n+1)​)2−∑i=2n​i2s(⌊in​⌋)，O(n23)O(n^{\\frac 2 3})O(n32​) 。 s(n)=∑i=1nσk(i)s(n)=\\sum_{i=1}^n\\sigma_k(i)s(n)=∑i=1n​σk​(i)：因为 σk=I∗idk⇒σk∗μ=idk\\sigma_k=I*id^k\\Rightarrow \\sigma_k*\\mu=id^kσk​=I∗idk⇒σk​∗μ=idk，能判定可杜教筛，不过这里直接从定义解更简单也更优，∑i=1nσk(i)=∑i=1n∑d∣idk=∑d=1ndk⌊nd⌋\\sum_{i=1}^n\\sigma_k(i)=\\sum_{i=1}^n\\sum_{d|i}d^k=\\sum_{d=1}^nd^k\\lfloor \\frac n d\\rfloor∑i=1n​σk​(i)=∑i=1n​∑d∣i​dk=∑d=1n​dk⌊dn​⌋，求自然数幂和即可 O(kn)O(k\\sqrt n)O(kn​)。 s(n)=∑i=1n(μ2∗μid)(i)s(n)=\\sum_{i=1}^n(\\mu^2*\\mu id)(i)s(n)=∑i=1n​(μ2∗μid)(i)，取 g=idg=idg=id，这样 μ2∗μid∗id=μ2\\mu^2*\\mu id*id=\\mu^2μ2∗μid∗id=μ2，转化为了筛 μ2\\mu^2μ2。 从定义入手发现是求 1∼n1\\sim n1∼n 不含平方因子的数，考虑容斥枚举即得 ∑i=1nμ(i)⌊ni2⌋\\sum_{i=1}^{\\sqrt n}\\mu(i)\\lfloor\\frac n {i^2}\\rfloor∑i=1n​​μ(i)⌊i2n​⌋ 。 也可以构造函数 f(n)=[n为完全平方数]f(n)=[n为完全平方数]f(n)=[n为完全平方数]，可得 f∗μ2=If*\\mu^2=If∗μ2=I，按杜教筛可推得 s(n)=n−∑i=2nf(i)s(⌊ni⌋)=n−∑i=2ns(⌊ni2⌋)s(n)=n-\\sum_{i=2}^nf(i)s(\\lfloor\\frac n i\\rfloor)=n-\\sum_{i=2}^{\\sqrt n}s(\\lfloor\\frac n {i^2}\\rfloor)s(n)=n−∑i=2n​f(i)s(⌊in​⌋)=n−∑i=2n​​s(⌊i2n​⌋)。 还可以构造函数 f(n)=n最大平方因子f(n)=\\sqrt{n最大平方因子}f(n)=n最大平方因子​，可得 s(n)=∑i=1n[f(i)=1]=∑i=1n∑d∣f(i)μ(d)s(n)=\\sum_{i=1}^n[f(i)=1]=\\sum^n_{i=1}\\sum_{d|f(i)}\\mu(d)s(n)=∑i=1n​[f(i)=1]=∑i=1n​∑d∣f(i)​μ(d)，而 d∣f(i)⇔d2∣id|f(i)\\Leftrightarrow d^2|id∣f(i)⇔d2∣i，所以 s(n)=∑d=1nμ(d)⌊nd2⌋s(n)=\\sum_{d=1}^{\\sqrt n}\\mu(d)\\lfloor \\frac n {d^2}\\rfloors(n)=∑d=1n​​μ(d)⌊d2n​⌋，由此还可发现 μ2(n)=∑d2∣nμ(d)\\mu^2(n)=\\sum_{d^2|n}\\mu(d)μ2(n)=∑d2∣n​μ(d)。 Powerful Number 筛 Powerful Number 定义：即不含幂次为 111 的素因项的数。 性质： 一定可以表示为 a2b3a^2b^3a2b3，分解质因数可证。 数量级为 O(∑ni23)=O(n)O(\\sum \\sqrt[3]{\\frac {n} {i^2}})=O(\\sqrt n)O(∑3i2n​​)=O(n​)，所以直接 dfs\\text{dfs}dfs 素因子指数求所有 PN\\text{PN}PN 复杂度为 O(n)O(\\sqrt n)O(n​)。 PN 筛 定义：大致为杜教筛扩展，找到一个能求前缀和的积性函数 ggg 满足 g(p)=f(p)g(p)=f(p)g(p)=f(p) 就能求 fff 的前缀和，瓶颈在杜教筛。 设 h=f/gh=f/gh=f/g，即逆狄利克雷卷积（仅作表示），满足积性函数则 hhh 必定唯一存在且也为积性函数，由于 g(p)=f(p)g(p)=f(p)g(p)=f(p)，所以 h(p)=0h(p)=0h(p)=0，发现 hhh 仅在 PNPNPN 处有值。 ∑i=1nf(i)=∑i=1n∑d∣ih(d)g(id)=∑d=1nh(d)Sg(⌊nd⌋)=∑d∈PNh(d)Sg(⌊nd⌋)\\sum^n_{i=1} f(i)=\\sum_{i=1}^n \\sum_{d|i} h(d)g(\\frac i d)=\\sum_{d=1}^nh(d)S_g(\\lfloor \\frac n d\\rfloor)=\\sum_{d\\in PN}h(d)S_g(\\lfloor \\frac n d\\rfloor)∑i=1n​f(i)=∑i=1n​∑d∣i​h(d)g(di​)=∑d=1n​h(d)Sg​(⌊dn​⌋)=∑d∈PN​h(d)Sg​(⌊dn​⌋)，杜教筛筛出 ggg 再暴力求出 hhh 在 PN\\text{PN}PN 出的所有值即可。 具体地，考虑 hhh 是积性函数仅需考虑 h(pk)h(p^k)h(pk) 的值，f(pk)=∑i=0kh(pi)g(pk−i)⇔h(pk)=f(pk)−∑i=0k−1h(pi)g(pk−i)f(p^k)=\\sum_{i=0}^k h(p^i)g(p^{k-i})\\Leftrightarrow h(p^k)=f(p^k)-\\sum_{i=0}^{k-1}h(p^i)g(p^{k-i})f(pk)=∑i=0k​h(pi)g(pk−i)⇔h(pk)=f(pk)−∑i=0k−1​h(pi)g(pk−i)，暴力算就行，能 O(1)O(1)O(1)求值的话复杂度不超过 O(n)O(\\sqrt n)O(n​)。 网络流 定义 流网络：带权有向图 G(V,E)\\text{G(V,E)}G(V,E)，含源点 s\\text ss 汇点 t\\text tt，边有容量 c(u,v)\\text{c(u,v)}c(u,v)。 可行流 f\\text ff ：{① 容量限制：0≤f(u,v)≤c(u,v) 流量不超过容量② 反对称性：f(u,v)=−f(v,u) 正着流出等于反着流进③ 流量守恒：∀x∈V/{s,t}∑f(u,x)=∑f(x,v) 除源汇点外流入量=流出量\\begin{cases} ①\\text{ 容量限制：} 0\\le f(u,v)\\le c(u,v) \\text{ 流量不超过容量} \\\\ ②\\text{ 反对称性：} f(u,v)=-f(v,u)\\ 正着流出等于反着流进 \\\\ ③\\text{ 流量守恒：}\\forall_{x\\in V/\\{s,t\\}} \\sum f(u,x)=\\sum f(x,v) \\text{ 除源汇点外流入量=流出量}\\end{cases}⎩⎨⎧​① 容量限制：0≤f(u,v)≤c(u,v) 流量不超过容量② 反对称性：f(u,v)=−f(v,u) 正着流出等于反着流进③ 流量守恒：∀x∈V/{s,t}​∑f(u,x)=∑f(x,v) 除源汇点外流入量=流出量​ 流量：∣f∣=∑f(s,v)−∑f(u,s)|f|=\\sum f(s,v)-\\sum f(u,s)∣f∣=∑f(s,v)−∑f(u,s) 源点流出量（减源点流入量），最大流即最大流量可行流。 残量网络 Gf\\text{G}_{\\text f}Gf​ ：由可行流 fff 决定，其中 Vf=V,Ef=E+E‾,c′(u,v)={c(u,v)−f(u,v)(u,v)∈Ef(u,v)(u,v)∈E‾V_f=V,E_f=E+\\overline E,c&#x27;(u,v)=\\begin{cases} c(u,v)-f(u,v) &amp; (u,v)\\in E \\\\ f(u,v) &amp; (u,v)\\in \\overline E\\end{cases}Vf​=V,Ef​=E+E,c′(u,v)={c(u,v)−f(u,v)f(u,v)​(u,v)∈E(u,v)∈E​ ，f′f&#x27;f′ 表示 GfG_fGf​ 的可行流，则 f+f′f+f&#x27;f+f′ 也是 GGG 的可行流，∣f+f′∣=∣f∣+∣f′∣|f+f&#x27;|=|f|+|f&#x27;|∣f+f′∣=∣f∣+∣f′∣，fff 为最大流 ⇔\\Leftrightarrow⇔ ∀∣f′∣=0\\forall |f&#x27;|=0∀∣f′∣=0。 增广路径：GfG_fGf​ 中从 s\\text ss 到 t\\text tt 的一条简单路径，是一条可行流。 割：将 VVV 分为两个点集 s∈S,t∈Ts\\in S,t\\in Ts∈S,t∈T。 割的容量：c(S,T)=∑u∈S∑v∈Tc(u,v)c(S,T)=\\sum_{u\\in S}\\sum_{v\\in T}c(u,v)c(S,T)=∑u∈S​∑v∈T​c(u,v) 割的流量：f(S,T)=∑u∈S∑v∈Tf(u,v)−f(v,u)f(S,T)=\\sum_{u\\in S}\\sum_{v\\in T}f(u,v)-f(v,u)f(S,T)=∑u∈S​∑v∈T​f(u,v)−f(v,u) f(S,T)≤c(S,T)f(S,T)\\le c(S,T)f(S,T)≤c(S,T)，且 f(S,T)=∣f∣f(S,T)=|f|f(S,T)=∣f∣。 最大流最小割定理：fff 是最大流 ⇔\\Leftrightarrow⇔ GfG_fGf​ 无增广路径 ⇔\\Leftrightarrow⇔ ∃[S,T] ∣f∣=c(S,T)\\exist_{[S,T]}\\ |f|=c(S,T)∃[S,T]​ ∣f∣=c(S,T)，即最大流 === 最小割。 证明一下，首先最大流 ≤\\le≤ 最小割这个显然，然后考虑最大流上的瓶颈边一定是一个割否则仍有增广路径，所以最大流 ≥\\ge≥ 最小割，得到最大流 === 最小割。 最大流 EK\\text{EK}EK 求最大流：不断 bfs\\text{bfs}bfs 找到一条增广路径累加进当前流并更新沿途的流量，找不到增广路径时即为最大流，复杂度 O(nm2)O(nm^2)O(nm2)，很松。 int hh,tt,q[N]; int pre[N],d[N]; bool use[N]; bool bfs() { hh=tt=0,memset(use,0,sizeof use); q[0]=s,use[s]=1,d[s]=p; while(hh&lt;=tt) { int x=q[hh++]; for(rint i=head[x];~i;i=nxt[i]) { int y=to[i]; if(!use[y]&amp;&amp;w[i]) { pre[y]=i,d[y]=min(d[x],w[i]); if(y==t) return 1; q[++tt]=y,use[y]=1; } } } return 0; } int ek() { int ans=0; while(bfs()) { ans+=d[t]; for(rint i=t;i!=s;i=to[pre[i]^1]) w[pre[i]]-=d[t],w[pre[i]^1]+=d[t]; } return ans; } Dinic\\text{Dinic}Dinic 求最大流：不断 bfs\\text{bfs}bfs 标记层数，再 dfs\\text{dfs}dfs 层间多路增广路径，有剪枝优化，复杂度 O(n2m)O(n^2m)O(n2m)，很松。 int cur[N],d[N]; int q[N],hh,tt; bool bfs() { for(rint i=1;i&lt;=n;i++) cur[i]=head[i],d[i]=0; q[hh=tt=0]=s,d[s]=1; while(hh&lt;=tt) { int x=q[hh++]; for(rint i=head[x];~i;i=nxt[i]) { int y=to[i]; if(!d[y]&amp;&amp;w[i]) { d[y]=d[x]+1; if(y==t) return 1; q[++tt]=y; } } } return 0; } int find(int x,int lim) { if(x==t) return lim; int sum=0; for(rint i=cur[x];~i&amp;&amp;sum&lt;lim;i=nxt[i]) { int y=to[i];cur[x]=i; if(d[y]==d[x]+1&amp;&amp;w[i]) { int flow=find(y,min(w[i],lim-sum)); if(!flow) d[y]=0; w[i]-=flow,w[i^1]+=flow,sum+=flow; } } return sum; } int dinic() { int ans=0,res; while(bfs()) while(res=find(s,p)) ans+=res; return ans; } 二分图最大匹配：sss 向集合 AAA 连容量为 111 的边，集合 BBB 向 ttt 连容量为 111 的边，可行匹配为对应的 AAA 向 BBB 连容量为 111 或 inf\\text{inf}inf 的边，最大流为最大匹配，DinicDinicDinic 复杂度 O(mn)O(m\\sqrt n)O(mn​)，可以扩展到限制每个元素最多匹配几次。 最小割方案：残量网络上找出连通块 SSS，剩下的即为 TTT，S→TS\\rightarrow TS→T 的边即为最小割方案。 可行边与必须边：即所有最小割方案的并集和交集。考虑残量网络是若干连通块，必须边即为直接连接 S,TS,TS,T 的边，可行边即为连接不同连通块的边，当然要保证最初的流网络连通。 无源汇上下界可行流：将 c1(u,v)≤f(u,v)≤c2(u,v)c_1(u,v)\\le f(u,v)\\le c_2(u,v)c1​(u,v)≤f(u,v)≤c2​(u,v) 转化为 0≤f(u,v)−c1(u,v)≤c2(u,v)−c1(u,v)0\\le f(u,v)-c_1(u,v)\\le c_2(u,v)-c_1(u,v)0≤f(u,v)−c1​(u,v)≤c2​(u,v)−c1​(u,v)，对于每个点以 ∑c1(u,x)−∑c1(x,v)\\sum c_1(u,x)-\\sum c_1(x,v)∑c1​(u,x)−∑c1​(x,v) 正负来判断是否放流或需流，建虚源汇点根据需放流连接每个点，跑最大流当流量流满时即有解，每条边加上原来的 c1c_1c1​ 即得方案。费用流和这个是一样的。 上下界最大流：由 ttt 向 sss 连一条容量 infinfinf 的边转为无源汇，求出无源汇上下界可行流，而由于现在虚源汇点必定满流所以在残量网络上与 s,ts,ts,t 无关，记下 t→st\\rightarrow st→s 的流量再加上删去该边后残量网络的最大流即为答案。 费用流和这个是一样的。 上下界最小流：同上下界最大流，最后跑残量网络的最大流时交换源汇点，用可行流减去逆最大流即可。 最大权闭合子图： 定义：带点权有向图的一个点集，满足无出边指向点集外的点。 简单割：只割 sss 邻边和 ttt 邻边的割。 考虑建立网络流模型使得闭合子图方案与割对应，通过最小割求解方案最值问题。 建立源汇点，原边容量为 inf\\text{inf}inf​，新连边 {s→∀点权&gt;0∀点权&lt;0→t\\begin{cases} s\\rightarrow \\forall 点权&gt;0 \\\\ \\forall 点权&lt;0 \\rightarrow t\\end{cases}{s→∀点权&gt;0∀点权&lt;0→t​，容量为点权绝对值。 原边为 inf⇒\\text{inf} \\Rightarrowinf⇒ 最小割为简单割，残量网络中的 SSS 点集为闭合子图。 考虑割去了正权点的边他一定会属于 TTT 点集，割去负权点的边他一定会属于 SSS 点集，所以 SSS 点集的权值和 === 正权点和 −-− 最小割。 故最大权闭合子图 === 正权点和 −-− 最小割。 最大密度子图： 定义：无向图的一个点集，满足其 内部边数点数\\frac {\\text{内部边数}} {\\text{点数}}点数内部边数​ 最大。 考虑二分，边转为向两边连出有向边的点，点权为 111 ，原点点权为 −mid-mid−mid，用最大权闭合子图判定即可，可以扩展到点边带权。 最小割树： 用于求解多组点对间最小割。不会证。 考虑先求解任意一个 cut(u,v)cut(u,v)cut(u,v) ，然后连边 [u,v,cut(u,v)][u,v,cut(u,v)][u,v,cut(u,v)]，接着根据 cut(u,v)cut(u,v)cut(u,v) 分成的两个点集往下递归建树，两点最小割即两点瓶颈路，复杂度 O(n3m+q)O(n^3m+q)O(n3m+q)，可以不用显式建树直接 O(n2)O(n^2)O(n2) 暴力存 disdisdis 数组，注意求最小割时要用到所有点边。 网络流技巧： 找出源汇点，以流或割对应题目的决策。 证明原题可行解与可行流对应，可以排除一定不优的解。 用 inf\\text{inf}inf 容量排除不参与割决策的边。 将点权转移到源汇边权上，利用简单最小割作最优化工具来决策点的取舍。 费用流 定义：边除了容量还带单位费用，流的费用就是所有边的单位费用 ×\\times× 经过的流量，费用流指最小费用最大流，即流量最大时的最小费用。 EK\\text{EK}EK 求费用流：不断 SPFA\\text{SPFA}SPFA 找费用最短路增广更新流量，复杂度能卡到 O(Fnm)O(Fnm)O(Fnm)，一般勉强看作 O(nm2)O(nm^2)O(nm2)。 int d[N],pre[N],flow[N]; bool use[N]; queue&lt;int&gt; q; bool spfa() { for(rint i=1;i&lt;=n;i++) d[i]=p,flow[i]=0; q.push(s),d[s]=0,flow[s]=p; while(!q.empty()) { int x=q.front();q.pop(); use[x]=0; for(rint i=head[x];~i;i=nxt[i]) { int y=to[i]; if(w[i]&amp;&amp;d[y]&gt;d[x]+f[i]) { d[y]=d[x]+f[i]; pre[y]=i,flow[y]=min(flow[x],w[i]); if(!use[y]) q.push(y),use[y]=1; } } } return flow[t]; } void ek() { int ans=0,cost=0; while(spfa()) { ans+=flow[t],cost+=flow[t]*d[t]; for(rint i=t;i!=s;i=to[pre[i]^1]) w[pre[i]]-=flow[t],w[pre[i]^1]+=flow[t]; } cout&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;cost&lt;&lt;endl; } 负环：由于反边等情况，在第一步最短路中可能会出现负环，要用到消圈算法，但是我不会，考虑不管。 费用优先流： 最大费用任意流：考虑费用一直在减少，单次费用即将为负时停止即可。 费用为正的最大流：考虑费用一直在减少，总费用即将为负时停止即可。 二分图相关 二分图判定 图为二分图 ⇔\\Leftrightarrow⇔ 没有奇环，dfs\\text{dfs}dfs 染色判定即可 。 二分图最大匹配 匈牙利算法： 一个匹配为最大匹配 ⇔\\Leftrightarrow⇔ 没有增广路。增广路就是交替走非匹配边和匹配边奇数步的路径。证明考虑首先最大匹配显然没有增广路，然后不是最大匹配的一定存在两个点是新加入的，以其作为增广路的两端是一定可行的，所以一定有增广路。 匈牙利算法就是遍历左侧的所有点进行 dfs\\text{dfs}dfs 尝试为其寻找增广路，复杂度 O(nm)O(nm)O(nm)。 bool dfs(int x,int now) { if(use[x]==now) return 0; use[x]=now; for(auto &amp;it:e[x]) if(!mch[it]||dfs(mch[it],now)) return mch[it]=x,1; return 0; } 具体来说右边的点只用到了 mch\\text{mch}mch，是可以不显式存在的，在一些拆点场景可以减少码量。 网络流 Dinic\\text{Dinic}Dinic ：O(mn)O(m\\sqrt n)O(mn​)。 Hall 定理 二分图完美匹配：钦定 ∣A∣≤∣B∣|A|\\le|B|∣A∣≤∣B∣，匹配数 === ∣A∣|A|∣A∣ 的一组匹配。 Hall\\text{Hall}Hall 定理：二分图存在完美匹配 ⇔\\Leftrightarrow⇔ ∀a⊆A\\forall a\\sube A∀a⊆A，设 bbb 为 aaa 能到达的右部点集的并，满足 ∣a∣≤∣b∣|a|\\le|b|∣a∣≤∣b∣。 exHall\\text{exHall}exHall 定理：二分图最大匹配 === ∣A∣−max⁡(∣a∣−∣b∣)|A|-\\max (|a|-|b|)∣A∣−max(∣a∣−∣b∣)。 二分图博弈 即二分图上交替行走谁不能走谁输，问题等价于起点是否为最大匹配必经点，证明考虑必经点走两步一定会到必经点。 判断二分图必经点可以用最小割必须边来判断。 也可以用匈牙利判断。具体地，考虑判断非必经点，在每次增广新点增广路失败的时候，那他一定是非必经点，同时与之相邻的匹配也都可以被替换掉，也为非必经点递归标记下去就行。 bool dfs(int x,int now) { if(use[x]==now) return 0; use[x]=now; for(auto &amp;it:e[x]) if(!mch[it]||dfs(mch[it],now)) return mch[it]=x,1; return 0; } void dfs2(int x,int now) { if(use[x]==now) return; use[x]=now,ans[x]=1; for(auto &amp;it:e[x]) if(mch[it]) dfs2(mch[it],now); } for(rint i=1;i&lt;=n;i++) if(!dfs(i,i)) dfs2(i,n+i); 二分图最小点覆盖 二分图最小点覆盖 === 最大匹配数，一般图是 NPC\\text{NPC}NPC。 证明考虑网络流，中间容量为 inf\\text{inf}inf，发现最小割等价于最小点覆盖。据此也可以拓展到点带权。 构造方案考虑我们得到了所有最大匹配的相关点，最小点覆盖一定在里面，枚举所有不相关点的相邻点是必选的，若剩下的都是相关点就任选一个继续做。 最小边覆盖：考虑每一次选边只能新覆盖 111 或 222 个点，覆盖 222 个点是一个匹配，故最小边覆盖 === 点数 −-− 最小点覆盖。 最大独立集 独立集：一组点集其两两之间无边。 团：一组点集其两两之间有边。最大独立集 === 补图最小团。 最大独立集的补集一定会将所有边覆盖，故最大独立集 === 最小点覆盖，最大权独立集 === 最小权点覆盖。 最小路径覆盖 路径覆盖：DAG\\text{DAG}DAG 上一组覆盖所有点的点不交路径。也称链覆盖。 考虑拆点，出点和入点形成二分图，发现一组路径覆盖对应到二分图的一组匹配，而路径数 === 点数 −-− 匹配数，转化为求最大匹配。 最小可重路径覆盖：在传递闭包后的 DAG\\text{DAG}DAG 上做最小路径点覆盖即可，这里的传递闭包即两点连通 ⇒\\Rightarrow⇒ 两点连边，搜索 O(nm)O(nm)O(nm) 不过 Floyd\\text{Floyd}Floyd 更好写。 Dilworth 定理 定义：对于任意有限偏序集，其最长反链中元素的数目必等于最小链覆盖中链的数目。 偏序集形成的图是 DAG\\text{DAG}DAG，放到 DAG\\text{DAG}DAG 上来说的话其实就是最小可重路径覆盖 === 最大不互达点集。 证明的话考虑放到 DAG\\text{DAG}DAG 上，记一个最小可重路径覆盖方案的路径结尾点集 E\\text EE，E\\text EE 每个点能走到不含自身的点集并为 E′\\text E&#x27;E′，若 E′\\text E&#x27;E′ 满足 \\text E\\and\\text E'=\\empty 即不互达则成立，否则对于 \\text E\\and\\text E' 中的每个点往沿着路径返回直到不属于 E′\\text E&#x27;E′ 得到方案，考虑路径上一定不会全部属于 E′\\text E&#x27;E′ 否则一定能被这条可重路径延伸包含所以一定能得到方案。 李超线段树 用途：支持 O(log⁡2)O(\\log^2)O(log2) 插入线段 O(log⁡)O(\\log)O(log) 查询单点最值。若全为直线则插入为 O(log⁡)O(\\log)O(log)，支持动态开点、持久化。 实现：标记永久化线段树，大值域需要离散化或动态开点，实数需要离散化。 v[N&lt;&lt;2] 维护覆盖区间 [l,r] 且是 mid 处最值的线段编号。 插入：递归到子区间，为空直接赋值返回，若中点值优于 v[now] 则与之交换，再考虑当前的线段是否比 v[now] 的左右端点优再往左右递归。由于两线段最多有一个交点，所以一次插入最多产生 O(log⁡)O(\\log)O(log) 个交点操作，每次操作又是 O(log⁡)O(\\log)O(log) 的，故为 O(log⁡2)O(\\log^2)O(log2)。 查询：计算递归到子区间沿途的所有线段取值最值即可。 struct tree{ //线段 #define cal(i,x) (k[i]*x+b[i]) int v[M&lt;&lt;2]; void insert(int l,int r,int x,int nowl=1,int nowr=m,int now=1) { int mid=(nowl+nowr)&gt;&gt;1; if(l&lt;=nowl&amp;&amp;nowr&lt;=r) { bool lp=cal(x,nowl)&gt;cal(v[now],nowl), rp=cal(x,nowr)&gt;cal(v[now],nowr), mp=cal(x,mid)&gt;cal(v[now],mid); if(!v[now]) lp=rp=mp=1; if(mp) swap(x,v[now]),lp^=1,rp^=1; if(nowl==nowr) return; if(lp) insert(l,r,x,nowl,mid,now&lt;&lt;1); if(rp) insert(l,r,x,mid+1,nowr,now&lt;&lt;1|1); return; } if(l&lt;=mid) insert(l,r,x,nowl,mid,now&lt;&lt;1); if(r&gt;mid) insert(l,r,x,mid+1,nowr,now&lt;&lt;1|1); } int ask(int x,int l=1,int r=m,int now=1) { if(l==r) return v[now]; int mid=(l+r)&gt;&gt;1; int res=(x&lt;=mid)?ask(x,l,mid,now&lt;&lt;1):ask(x,mid+1,r,now&lt;&lt;1|1); if(!v[now]||!res) return v[now]|res; double ll=cal(v[now],x),rr=cal(res,x); if(abs(ll-rr)&lt;eps) return min(res,v[now]); return ll&gt;rr?v[now]:res; } }t; struct tree{ //直线 int v[N&lt;&lt;2]; #define cal(i,x) (k[i]*x+b[i]) void insert(int x,int l=1,int r=m,int now) { if(!v[now]) return v[now]=x,void(); int mid=(l+r)&gt;&gt;1; if(cal(x,mid)&lt;cal(v[now],mid)) swap(v[now],x); if(l==r) return; if(cal(x,l)&lt;cal(v[now],l)) insert(x,l,mid,now&lt;&lt;1); if(cal(x,r)&lt;cal(v[now],r)) insert(x,mid+1,r,now&lt;&lt;1|1); } int ask(int x,int l=1,int r=m,int now) { if(l==r) return v[now]; int mid=(l+r)&gt;&gt;1, res=(x&lt;=mid)?ask(x,l,mid,now&lt;&lt;1):ask(x,mid+1,r,now&lt;&lt;1|1); if(!res||!v[now]) return res|v[now]; return cal(res,x)&lt;cal(v[now],x)?res:v[now]; } }t; ODT 颜色段均摊 用途：维护单纯区间赋值或纯随机数据下支持遍历，复杂度 O(nlog⁡log⁡n)O(n\\log\\log n)O(nloglogn)。 实现：把值相同的区间合并成一个节点，用 set\\text{set}set 维护。 对于 set\\text{set}set 中不参与比较的变量参数用 mutable 修饰可以支持修改，这里的区间值需要 mutable。 核心操作：auto split(int x) 将 [x\\text{[x}[x 处切断并返回 x\\text xx 处迭代器，注意实现细节，区间操作都通过 split 来取出区间暴力执行。 struct node{ int l,r; mutable int v; bool operator &lt;(const node&amp; x)const{return l&lt;x.l;} }; set&lt;node&gt; odt; auto split(int x) { auto it=odt.lower_bound({x,0,0}); if(it!=odt.end()&amp;&amp;it-&gt;l==x) return it; it--; int l=it-&gt;l,r=it-&gt;r,v=it-&gt;v; odt.erase(it),odt.insert({l,x-1,v}); return odt.insert({x,r,v}).first; } void assign(int l,int r,int v) { auto itr=split(r+1),itl=split(l); odt.erase(itl,itr),odt.insert({l,r,v}); } void add(int l,int r,int v) //随机操作和范围时支持遍历,不随机只能骗分 { auto itr=split(r+1),itl=split(l); for(auto it=itl;it!=itr;it++) it-&gt;v+=v; } K-D Tree 用途：维护高维空间点集的检索，空间复杂度 O(n)O(n)O(n)。 建树：类似于线段树的 Leafy\\text{Leafy}Leafy 结构，每个节点维护一个包含区间内所有点的超矩形，建树时交替维度选当前维度的中位数为 mid\\text{mid}mid 分治就能保证树高为 O(log⁡)O(\\log)O(log)，复杂度 O(nlog⁡)O(n\\log)O(nlog)。 查询：对一个超矩形进行询问，在 KDT\\text{KDT}KDT 上最多涉及 O(n1−1k)O(n^{1-\\frac 1 k})O(n1−k1​) 个节点，类似线段树往左右儿子递归询问即可，复杂度 O(n1−1k)O(n^{1-\\frac 1 k})O(n1−k1​)。 插入：设阈值 B\\text BB，插入的点数小于 B\\text BB 则在 KDT\\text{KDT}KDT 外暴力统计，大于阈值则重构 KDT\\text{KDT}KDT，复杂度 O(nBnlog⁡+n(n1−1k+B))O(\\frac n B n\\log+n(n^{1-\\frac 1 k}+B))O(Bn​nlog+n(n1−k1​+B))，取 B=nlog⁡B=\\sqrt{n\\log}B=nlog​ 得到 O(nnlog⁡+n2−1k)O(n\\sqrt{n\\log}+n^{2-\\frac 1 k})O(nnlog​+n2−k1​)。 删除：能额外排除的话可以类似插入一样设阈值重构，否则只能递归到叶子消去贡献再类似替罪羊树做子树阈值重构，没有实现过。 邻域查询：信息不能在超矩形上完全维护可能要往下递归查询时，复杂度 O(n)O(n)O(n)，可能能在 KDT\\text{KDT}KDT 上维护信息做启发式搜索乱搞。 struct node{ int x,y,val; }a[N]; bool cmpx(const node &amp;A,const node &amp;B){return A.x&lt;B.x;} bool cmpy(const node &amp;A,const node &amp;B){return A.y&lt;B.y;} struct data{ int xl,xr,yl,yr,val; bool Apart(const data &amp;A)const{return xl&gt;A.xr||xr&lt;A.xl||yl&gt;A.yr||yr&lt;A.yl;} bool inclu(const data &amp;A)const {return xl&lt;=A.xl&amp;&amp;A.xr&lt;=xr &amp;&amp; yl&lt;=A.yl&amp;&amp;A.yr&lt;=yr;} bool inclu(const node &amp;A)const {return xl&lt;=A.x&amp;&amp;A.x&lt;=xr &amp;&amp; yl&lt;=A.y&amp;&amp;A.y&lt;=yr;} }; struct kdtree{ data v[N&lt;&lt;2]; void build(int l,int r,int now=1,bool how=0) { if(l==r) return v[now]={a[l].x,a[l].x,a[l].y,a[l].y,a[l].val},void(); int mid=(l+r)&gt;&gt;1; nth_element(a+l,a+mid,a+r+1,how?cmpx:cmpy); build(l,mid,now&lt;&lt;1,!how),build(mid+1,r,now&lt;&lt;1|1,!how); int ls=now&lt;&lt;1,rs=now&lt;&lt;1|1; v[now]={min(v[ls].xl,v[rs].xl),max(v[ls].xr,v[rs].xr), min(v[ls].yl,v[rs].yl),max(v[ls].yr,v[rs].yr), v[ls].val+v[rs].val}; } data aks; void ask(int l,int r,int now=1) { if(aks.Apart(v[now])) return; if(aks.inclu(v[now])) return aks.val+=v[now].val,void(); int mid=(l+r)&gt;&gt;1; ask(l,mid,now&lt;&lt;1),ask(mid+1,r,now&lt;&lt;1|1); } void dfs(int l,int r,int now=1) //乱搞 { double d=aks.dis(v[now]); if(d&gt;ans&amp;&amp;!aks.in(v[now])) return; if(l==r) { if(d==p) { if(!same) same=1; else ans=0; }else ans=d; return; } int mid=(l+r)&gt;&gt;1; if(aks.dis(v[now&lt;&lt;1])&lt;aks.dis(v[now&lt;&lt;1|1])) dfs(l,mid,now&lt;&lt;1),dfs(mid+1,r,now&lt;&lt;1|1); else dfs(mid+1,r,now&lt;&lt;1|1),dfs(l,mid,now&lt;&lt;1); } }t; int nowl,nowr; void insert() { a[++nowr]={read(),read(),read()}; if((nowr-nowl)*(nowr-nowl)&gt;nowr*40) t.build(1,nowl=nowr); break; } 莫队 普通莫队 定义：对于序列上的区间询问问题，考虑每一个询问从上一个询问逐步拓展缩减区间得到答案，注意可能有 nowl&gt;nowr 要先拓展，离线询问排序能做到 O(mn)O(m\\sqrt n)O(mn​)。 实现：考虑分块，将询问按 &lt;左端点块编号,右端点&gt; 排序，设块长为 B\\text BB，那么对于每个块中的询问，每个会将左端点移动 O(B)O(B)O(B) 次，总体会将右端点移动 O(n)O(n)O(n) 次，所以总共是 O(mB+n2B)O(mB+\\frac {n^2} B)O(mB+Bn2​) 次拓展缩减，O(m)O(m)O(m) 次查询，假设操作 O(1)O(1)O(1) 的话 B\\text BB 取 nm\\frac n {\\sqrt m}m​n​ 得到 O(nm)O(n\\sqrt m)O(nm​)，实际上 B\\text BB 取定值更简单有效。 奇偶排序：上述排序在相邻块间转移时右端点会先移回左端再到右端，考虑在左端点为偶块时右端点降序排序就能有效减少冗余。 带修莫队 修改相当于多了一维时间维度，修改操作可以看作是与当前的序列 swap\\text{swap}swap，若在当前区间中则要进行维护，排序按 &lt;左端点块编号,右端点块编号,时间&gt; 排序，用类似的分析方法 B\\text BB 取 O(n2tm3)O(\\sqrt[3]{\\frac {n^2t} m})O(3mn2t​​) 得到 O(n2m2t3)O(\\sqrt[3]{n^2m^2t})O(3n2m2t​)，同阶即为 O(n53)O(n^{\\frac 5 3})O(n35​)。 struct data{ int l,r,id,t; bool operator &lt;(const data &amp;A)const { if(l/kuai!=A.l/kuai) return l&lt;A.l; if(r/kuai!=A.r/kuai) return r&lt;A.r; return t&lt;A.t; } }q[N]; struct change{int k,x;}ch[N]; int nowans,c[M]; void add(int x){if(!c[a[x]]++) nowans++;} void del(int x){if(!--c[a[x]]) nowans--;} void change(int x,int l,int r) { int pos=ch[x].k; if(l&lt;=pos&amp;&amp;pos&lt;=r) del(pos),swap(ch[x].x,a[pos]),add(pos); else swap(ch[x].x,a[pos]); } void modui() { sort(q+1,q+nq+1); int nowl=q[1].l,nowr=q[1].r,nowt=q[1].t; for(rint i=nowl;i&lt;=nowr;i++) add(i); for(rint i=1;i&lt;=nowt;i++) change(i,nowl,nowr); ans[q[1].id]=nowans; for(rint i=2;i&lt;=nq;i++) { int l=q[i].l,r=q[i].r,t=q[i].t; while(nowl&gt;l) add(--nowl); while(nowr&lt;r) add(++nowr); while(nowl&lt;l) del(nowl++); while(nowr&gt;r) del(nowr--); while(nowt&lt;t) change(++nowt,nowl,nowr); while(nowt&gt;t) change(nowt--,nowl,nowr); ans[q[i].id]=nowans; } } 回滚莫队 定义：即只有拓展操作或只有缩减操作的莫队，复杂度 O(nm)O(n\\sqrt m)O(nm​)。 实现：考虑只有拓展操作，询问按 &lt;左端点块编号,右端点&gt; 排序，如果当前询问换块了就推倒从块的右端点空区间开始，如果右端点在左端点块中就单独暴力扫，现在当前区间一定包含于询问区间，考虑先拓展右端点，然后备份，再拓展左端点回答询问，最后回退至备份，这样复杂度同样是 O(nm)O(n\\sqrt m)O(nm​)，共有 O(m)O(m)O(m) 次备份操作，只缩减操作可以类似解决。 void add(int x){ cnt[a[x]]++,nowans=max(nowans,cnt[a[x]]*b[a[x]]); } void modui() { sort(q+1,q+1+m); for(rint i=1;i&lt;=m;) { int nowkuai=q[i].l/kuai; while(i&lt;=m&amp;&amp;q[i].r/kuai==nowkuai) { nowans=0; for(rint j=q[i].l;j&lt;=q[i].r;j++) add(j); ans[q[i].id]=nowans; for(rint j=q[i].l;j&lt;=q[i].r;j++) cnt[a[j]]--; i++; } nowans=0; int edge=min(n+1,(nowkuai+1)*kuai),l=edge,r=edge-1; while(i&lt;=m&amp;&amp;q[i].l/kuai==nowkuai) { while(r&lt;q[i].r) add(++r); int backup=nowans; while(l&gt;q[i].l) add(--l); ans[q[i].id]=nowans; while(l&lt;edge) cnt[a[l++]]--; nowans=backup; i++; } for(rint j=edge;j&lt;=r;j++) cnt[a[j]]--; } } 树上莫队 定义：处理树上的路径询问问题，转化成 dfs\\text{dfs}dfs 序上的普通莫队，复杂度 O(nm)O(n\\sqrt m)O(nm​)。 实现：dfs\\text{dfs}dfs 序列就是记录节点在 dfs\\text{dfs}dfs 进入和离开时的长为 2n\\text{2n}2n 的序列，考虑路径 (x,y)(x,y)(x,y)，先钦定 first[x]&lt;first[y] ，这样当 lca=xlca=xlca=x 时路径上的点就为 [first[x],first[y]][first[x],first[y]][first[x],first[y]] 上出现一次的点，否则为 [last[x],first[y]][last[x],first[y]][last[x],first[y]] 上出现一次的点加上 lcalcalca，容易用 bool\\text{bool}bool 记录出现次数实现决定点添加删除。 void add(int x) { use[x]^=1; if(use[x]) nowans+=a[c[x]]*b[++cnt[c[x]]]; else nowans-=a[c[x]]*b[cnt[c[x]]--]; } void change(int x) { if(use[ch[x].x]) add(ch[x].x),swap(ch[x].v,c[ch[x].x]),add(ch[x].x); else swap(ch[x].v,c[ch[x].x]); } void modui() { sort(q+1,q+1+cntq); int nowl=q[1].l,nowr=nowl-1,nowt=0; for(rint i=1;i&lt;=cntq;i++) { int l=q[i].l,r=q[i].r,t=q[i].t; while(nowl&gt;l) add(o[--nowl]); while(nowr&lt;r) add(o[++nowr]); while(nowl&lt;l) add(o[nowl++]); while(nowr&gt;r) add(o[nowr--]); if(q[i].fa) add(q[i].fa); while(nowt&lt;t) change(++nowt); while(nowt&gt;t) change(nowt--); ans[q[i].id]=nowans; if(q[i].fa) add(q[i].fa); } } signed main() { for(rint i=1;i&lt;=m;i++) if(read()) { int x=read(),y=read(),fa=lca(x,y); if(first[x]&gt;first[y]) swap(x,y); if(x==fa) q[++cntq]={first[x],first[y],0,cntc,cntq}; else q[++cntq]={last[x],first[y],fa,cntc,cntq}; }else ch[++cntc]={read(),read()}; modui(); } 决策单调性 区间包含单调性：∀a≤b≤c≤d\\forall a\\le b\\le c\\le d∀a≤b≤c≤d，w(b,c)≤w(a,d)w(b,c)\\le w(a,d)w(b,c)≤w(a,d) 四边形不等式：∀a≤b≤c≤d\\forall a\\le b\\le c\\le d∀a≤b≤c≤d，w(a,c)+w(b,d)≤w(a,d)+w(b,c)w(a,c)+w(b,d)\\le w(a,d)+w(b,c)w(a,c)+w(b,d)≤w(a,d)+w(b,c)，即交叉小于包含，若等号恒成立称为四边形恒等式。 中点2D1D：fl,r=min⁡k=lr−1{fl,k+fk+1,r}+w(l,r)f_{l,r}=\\min_{k=l}^{r-1}\\{f_{l,k}+f_{k+1,r}\\}+w(l,r)fl,r​=mink=lr−1​{fl,k​+fk+1,r​}+w(l,r) 若 w(l,r)w(l,r)w(l,r) 满足区间包含单调性和四边形不等式，则 fl,rf_{l,r}fl,r​ 满足四边形不等式。 若 fl,rf_{l,r}fl,r​ 满足四边形不等式，记 ml,rm_{l,r}ml,r​ 表示最优决策点，则有 ml,r−1≤ml,r≤ml+1,rm_{l,r-1}\\le m_{l,r} \\le m_{l+1,r}ml,r−1​≤ml,r​≤ml+1,r​，枚举量降为 O(n2)O(n^2)O(n2)。 for(rint len=2;len&lt;=n;len++) for(rint l=1,r=len;r&lt;=n;l++,r++) { f[l][r]=p; for(rint k=m[l][r-1];k&lt;=m[l+1][r];k++) if(f[l][r]&gt;f[l][k]+f[k+1][r]+w(l,r)) f[l][r]=f[l][k]+f[k+1][r]+w(l,r),m[l][r]=k; } 分层2D1D：fi,j=min⁡k&lt;j{fi−1,k+w(k,j)}f_{i,j}=\\min_{k&lt;j}\\{f_{i-1,k}+w(k,j)\\}fi,j​=mink&lt;j​{fi−1,k​+w(k,j)} 若 w(i,j)w(i,j)w(i,j) 满足四边形不等式，则 fi,jf_{i,j}fi,j​ 满足四边形不等式，有 mi−1,j≤mi,j≤mi,j+1m_{i-1,j}\\le m_{i,j} \\le m_{i,j+1}mi−1,j​≤mi,j​≤mi,j+1​，枚举量降为 O((n+m)m)O((n+m)m)O((n+m)m)，也可以将每一层间的转移看作指针1D1D，复杂度 O(nmlog⁡)O(nm\\log)O(nmlog)，这里分治时能使用类似莫队的方法求 w(l,r)w(l,r)w(l,r)，一次分治会移动 O(mlog⁡)O(m\\log)O(mlog) 次。 wqs 带权二分：若分 kkk 层中每层的值是凸的则可以用带权二分去二分斜率切凸包上的点，二分每次划分的额外价值，check 划分1D1D分了几层即可，复杂度 O(nlog⁡)O(n\\log)O(nlog)，若值是整数那么斜率一定也是整数，为了处理共线要在每一次求得的切线在 x=kx=kx=k 的值中取最优值，构造方案考虑扰动避免共线且保证凸性。 int check(int mid) { q[hh=tt=0]=0; for(rint i=1;i&lt;=n;i++) { while(hh&lt;tt&amp;&amp;ti[hh+1]==i) hh++; f[i]=f[q[hh]]+w(q[hh]+1,i)-mid,m[i]=m[q[hh]]+1; while(hh&lt;tt&amp;&amp;ti[tt]&gt;=cal(q[tt],i)) tt--; q[++tt]=i,ti[tt]=cal(q[tt-1],i); } ans=max(ans,f[n]+k*mid); if(m[n]==k){cout&lt;&lt;ans&lt;&lt;endl;exit(0);} return m[n]; } signed main() { int l=-p,r=1; while(l+1&lt;r) { int mid=(l+r)&gt;&gt;1; if(check(mid)&lt;k) l=mid; else r=mid; } cout&lt;&lt;ans&lt;&lt;endl; } 划分1D1D：fr=min⁡l=1r−1{fl+w(l,r)}f_r=\\min_{l=1}^{r-1}\\{f_l+w(l,r)\\}fr​=minl=1r−1​{fl​+w(l,r)} 若 w(l,r)w(l,r)w(l,r) 满足四边形不等式，则有 ml≤mrm_l\\le m_rml​≤mr​ 具有决策单调性。 若 fl+w(l,r)f_l+w(l,r)fl​+w(l,r) 满足单谷性且 fff 有决策单调性，双指针解决，复杂度 O(n)O(n)O(n)。 若 w(l,r)w(l,r)w(l,r) 为凸函数，用凸函数二分栈/二分队列解决，复杂度 O(nlog⁡)O(n\\log)O(nlog)。 凸函数二分队列：考虑 w(l,r)w(l,r)w(l,r) 为下凸函数求最小值或上凸函数求最大值，后入队的元素衰减速度更快，元素入队时二分求出优于前面元素的时间，保证队列中迭代时间单调即可，复杂度 O(nlog⁡)O(n\\log)O(nlog)，若能 O(1)O(1)O(1) 计算优于时间则为普通单调队列，本质上是简单维护凸壳。 凸函数二分栈：考虑 w(l,r)w(l,r)w(l,r) 为下凸函数求最大值或上凸函数求最小值，后入栈的元素增加速度更慢，元素入栈时二分求出优于前面元素的时间，保证队列中迭代时间单调即可，复杂度 O(nlog⁡)O(n\\log)O(nlog)，若能 O(1)O(1)O(1) 计算优于时间则为普通单调栈，本质上是简单维护凸壳，与决策单调性无关。 若 fff 有决策单调性，可以 cdq\\text{cdq}cdq 分治套分治 O(nlog⁡2)O(n\\log^2)O(nlog2) 或者二分队列 O(nlog⁡)O(n\\log)O(nlog) 解决，cdq\\text{cdq}cdq 优势在于能类似莫队地维护 w(l,r)w(l,r)w(l,r)。 void work(int l,int r,int kl,int kr) { if(l&gt;r||kl&gt;kr) return; int mid=(l+r)&gt;&gt;1,kmid=kl; for(rint i=kl;i&lt;=kr;i++) { int val=f[i]+w(i+1,mid)-cost; if(val&lt;f[mid]) f[mid]=val,m[mid]=m[i]+1,kmid=i; } work(l,mid-1,kl,kmid),work(mid+1,r,kmid,kr); } void cdq(int l,int r) { if(l==r) return; int mid=(l+r)&gt;&gt;1; cdq(l,mid),work(mid+1,r,l,mid),cdq(mid+1,r); } 二分队列：队列维护三元组 (l,r,x)(l,r,x)(l,r,x) 表示 ml∼r=xm_{l\\sim r}=xml∼r​=x，每次结算时更新队尾的一段 mx∼n=im_{x\\sim n}=imx∼n​=i 插回队列即可。 struct data{ int l,r,x; }q[N]; int cal(int tt,int y) { int l=max(q[tt].l,y),r=q[tt].r+1; while(l+1&lt;r) { int mid=(l+r)&gt;&gt;1; if(f[q[tt].x]+w(q[tt].x+1,mid)&lt;f[y]+w(y+1,mid)) r=mid; else l=mid; } return r; } void work() { q[hh=tt=0]={1,n,0}; for(rint i=1;i&lt;=n;i++) { if(hh&lt;=tt&amp;&amp;q[hh].r&lt;i) hh++; else q[hh].l=i; f[i]=f[q[hh].x]+w(q[hh].x+1,i); while(hh&lt;=tt&amp;&amp;f[q[tt].x]+w(q[tt].x+1,q[tt].l)&lt;=f[i]+w(i+1,q[tt].l)) tt--; if(hh&gt;tt) q[++tt]={i+1,n,i}; else { int x=cal(tt,i); q[tt].r=x-1,q[++tt]={x,n,i}; } } } 斜率优化：考虑 w(l,r)=a(i)+b(j)+c(i)d(j)+Cw(l,r)=a(i)+b(j)+c(i)d(j)+Cw(l,r)=a(i)+b(j)+c(i)d(j)+C，考虑变量 b(j)+c(i)d(j)b(j)+c(i)d(j)b(j)+c(i)d(j) 是对若干直线在某点上取极值，需要维护插入直线维护极值，李超树能够 O(nlog⁡2)O(n\\log^2)O(nlog2) 维护一般情况，不过通常会有性质 ① 插入斜率有序 ② 查询位置单调，①② 单调队列/单调栈就能维护，① 再在凸壳上二分位置就行。 指针1D1D：fr=min⁡l=1r−1w(l,r)f_r=\\min_{l=1}^{r-1}w(l,r)fr​=minl=1r−1​w(l,r) 若 w(l,r)w(l,r)w(l,r) 满足四边形不等式，则有 ml≤mrm_l\\le m_rml​≤mr​，定义分治过程 (l,r,kl,kr)(l,r,kl,kr)(l,r,kl,kr) 求解 fl∼rf_{l\\sim r}fl∼r​ 且决策点在 kl∼krkl\\sim krkl∼kr 中，复杂度 O(nlog⁡)O(n\\log)O(nlog)。 void work(int l,int r,int kl,int kr) { if(l&gt;r) return; int mid=(l+r)&gt;&gt;1,kmid=kl; for(rint i=kl;i&lt;=min(kr,mid);i++) { int res=w(i,mid); if(res&gt;f[mid]) f[mid]=res,kmid=i; } work(l,mid-1,kl,kmid),work(mid+1,r,kmid,kr); } 满足四边形不等式的性质： 若 w1(l,r),w2(l,r)w_1(l,r),w_2(l,r)w1​(l,r),w2​(l,r) 满足四边形不等式（或区间包含单调性），则 ∀c1,c2≥0\\forall c_1,c_2\\ge0∀c1​,c2​≥0，c1w1(l,r)+c2w2(l,r)c_1w_1(l,r)+c_2w_2(l,r)c1​w1​(l,r)+c2​w2​(l,r) 也满足四边形不等式（或区间包含单调性）。 若存在 f(x),g(x)f(x),g(x)f(x),g(x) 使得 w(l,r)=f(r)−g(l)w(l,r)=f(r)-g(l)w(l,r)=f(r)−g(l)，则 w(l,r)w(l,r)w(l,r) 满足四边形恒等式。当 f,gf,gf,g 单增时 w(l,r)w(l,r)w(l,r) 还满足区间包含单调性。 若 w(l,r)w(l,r)w(l,r) 满足四边形不等式和区间包含单调性，则对于单增下凸函数 h(x)h(x)h(x) 有 h(w(l,r))h(w(l,r))h(w(l,r)) 满足四边形不等式和区间包含单调性，对于下凸函数 h(x)h(x)h(x) 有 h(w(l,r))h(w(l,r))h(w(l,r)) 满足四边形不等式。 杂项 二维哈希 记一个矩阵 aaa 的哈希值为 ∑i=1n∑j=1mai,jp1n−ip2m−j\\sum_{i=1}^n\\sum_{j=1}^ma_{i,j}p_1^{n-i}p_2^{m-j} i=1∑n​j=1∑m​ai,j​p1n−i​p2m−j​ 类似前缀和可以 O(1)O(1)O(1) 求子矩阵哈希值，H(x2,y2)−H(x1−1,y2)p1x2−x1+1−H(x2,y1−1)p2y2−y1+1+H(x1−1,y1−1)p1x2−x1+1p2y2−y1+1H(x_2,y_2)-H(x_1-1,y_2)p_1^{x_2-x_1+1}-H(x_2,y_1-1)p_2^{y_2-y_1+1}+H(x_1-1,y_1-1)p_1^{x_2-x_1+1}p_2^{y_2-y_1+1}H(x2​,y2​)−H(x1​−1,y2​)p1x2​−x1​+1​−H(x2​,y1​−1)p2y2​−y1​+1​+H(x1​−1,y1​−1)p1x2​−x1​+1​p2y2​−y1​+1​。 枚举子矩形 暴力枚举端点是 O(n2m2)O(n^2m^2)O(n2m2) 的，考虑先大力枚举行的两个端点，然后再利用前缀和的思想统计列，就是把左端贡献记在桶里，不断移右端查询并更新桶即可，可以做到 O(n2m)=O(SS)O(n^2m)=O(S\\sqrt S)O(n2m)=O(SS​)。 图三四元环计数 无向图三元环计数：考虑将边定向，由度数小的连向度数大的，相同则按编号，考虑在形成的 DAG 直接枚举三元环的复杂度为 ∑ini×outi\\sum in_i\\times out_i∑ini​×outi​ ，因为 outi≤duiout_i\\leq du_iouti​≤dui​ 且 duson of i≥duidu_{son\\ of \\ i}\\geq du_iduson of i​≥dui​ ，考虑 outi∗outi≤∑outiduson of i≤2mout_i*out_i \\leq \\sum^{out_i}du_{son\\ of \\ i}\\leq 2mouti​∗outi​≤∑outi​duson of i​≤2m ，所以 outi≤2mout_i\\leq \\sqrt {2m}outi​≤2m​ ，复杂度为 O(mm)O(m\\sqrt m)O(mm​)。 for(rint i=1;i&lt;=n;i++) { for(auto &amp;it:e[i]) use[it]=1; for(auto &amp;it:e[i]) for(auto &amp;jt:e[it]) if(use[jt]) ans++; for(auto &amp;it:e[i]) use[it]=0; } 无向图四元环计数：同样定向并枚举，有向四元环有 2+22+22+2 和 3+13+13+1 两种形式，发现都可以被唯一表示为两侧无向边+有向边的形式，枚举四元环的一侧计数即可，复杂度为 ∑dui×outi\\sum du_i\\times out_i∑dui​×outi​ 同理可得 O(mm)O(m\\sqrt m)O(mm​)。 for(rint i=1;i&lt;=n;i++) { for(auto it:ee[u]) for(auto jt:e[it]) if(rk[jt]&gt;rk[i]) ans+=cnt[jt]++; for(auto it:ee[u]) for(auto jt:e[it]) cnt[jt]=0; } 有向图三四元环计数：转无向图按无向图的做，在找到环的时候 check 一下是否合法即可。 树哈希 O(n)O(n)O(n)，有根树 h[u]=∑hash(h[v])h[u]=\\sum hash(h[v])h[u]=∑hash(h[v])，无根树以重心为根即可，双重心就做两次。 mt19937_64 rd(19260817); unordered_map&lt;uint,uint&gt; mp; uint hsh(const uint x){return mp.find(x)==mp.end()?mp[x]=rd():mp[x];} uint dfs(int x=1,int fa=1) { uint ha=0; for(auto &amp;it:e[x]) if(it!=fa) ha+=hsh(dfs(it,x)); return ha; } 虚树 将关键点按 dfn\\text{dfn}dfn 排序，将相邻两点的 LCA\\text{LCA}LCA 加入后再次排序，单调栈求出连边关系。 void build() { sort(a+1,a+num+1,cmp); for(rint i=2,nn=num;i&lt;=nn;i++) a[++num]=lca(a[i-1],a[i]); sort(a+1,a+num+1,cmp),num=unique(a+1,a+num+1,Equal)-a-1; for(rint i=1;i&lt;=num;i++) e[a[i]].clear(); int top=0; for(rint i=1;i&lt;=num;i++) { while(top&amp;&amp;dfn[stk[top]]+sz[stk[top]]-1&lt;dfn[a[i]]) top--; if(top) e[stk[top]].push_back(a[i]),e[a[i]].push_back(stk[top]); stk[++top]=a[i]; } } 二项式反演 恰好和至少的转换：设 fff 表示恰好的方案数，ggg 表示至少的方案数，则有： g(i)=∑j=in(ji)f(j)⇔f(i)=∑j=in(−1)j−i(ji)g(j)g(i)=\\sum_{j=i}^n\\binom j i f(j)\\Leftrightarrow f(i)=\\sum_{j=i}^n(-1)^{j-i}\\binom j i g(j) g(i)=j=i∑n​(ij​)f(j)⇔f(i)=j=i∑n​(−1)j−i(ij​)g(j) 恰好和至多的转换：设 fff 表示恰好的方案数，ggg 表示至多的方案数，则有： g(i)=∑j=0i(ij)f(j)⇔f(i)=∑j=0i(−1)i−j(ij)g(j)g(i)=\\sum_{j=0}^i\\binom i j f(j)\\Leftrightarrow f(i)=\\sum_{j=0}^i(-1)^{i-j}\\binom i j g(j) g(i)=j=0∑i​(ji​)f(j)⇔f(i)=j=0∑i​(−1)i−j(ji​)g(j) 高维前缀和 sumi=∑j⊆iajsum_i=\\sum_{j \\subseteq i} a_jsumi​=∑j⊆i​aj​，暴力求是 O(3n)O(3^n)O(3n) 的，考虑对于每一维分别做前缀和就可以做到 O(n2n)O(n2^n)O(n2n)，后缀和同理。 for(rint i=0;i&lt;n;i++) for(rint j=0;j&lt;1&lt;&lt;n;j++) if(j&gt;&gt;i&amp;1) a[j]+=a[j^(1&lt;&lt;i)]; for(rint i=0;i&lt;n;i++) //后缀和 for(rint j=0;j&lt;1&lt;&lt;n;j++) if(!(j&gt;&gt;i&amp;1)) a[j]+=a[j^(1&lt;&lt;i)]; 线段树合并 考虑树上每个节点建一棵权值线段树维护子树信息，进行线段树合并时空复杂度都是 O(nlog⁡)O(n\\log)O(nlog) 的，一般离线询问直接在原树上合并，需要在线询问则合并需要新开节点，空间带二倍常数，实际都是能开多大开多大。 int root[N],idx; struct node{ int ls,rs;data x; }v[N*50]; int merge(int x,int y,int l=1,int r=n) { if(!x||!y) return x|y; if(l==r) return v[x].x+=v[y].x,x; int mid=(l+r)&gt;&gt;1; v[x].ls=merge(v[x].ls,v[y].ls,l,mid), v[x].rs=merge(v[x].rs,v[y].rs,mid+1,r); v[x].x=v[x.ls].x+v[x.rs].x; return x; } void sel(int x=1,int fa=1) { for(auto &amp;it:e[x]) if(it!=fa) sel(it,x),root[x]=merge(root[x],root[it]); ans[x]=ask(root[x]); } dsu on tree 也叫树上启发式合并或静态链分治，对于统计子树信息，考虑递归轻儿子并消除影响，再递归重儿子不消除影响，最后暴力加入所有轻儿子中的点的影响，这样启发式复杂度是 O(nlog⁡)O(n\\log)O(nlog) 且空间为线性。 int sta[N],top,res,ans[N]; int f[1&lt;&lt;22]; void init(){ res=0; while(top) f[sta[top--]]=-p; } void sel(int k,int x){ res=max(res,f[k]+x); for(rint i=0;i&lt;22;i++) res=max(res,f[k^1&lt;&lt;i]+x); } void add(int k,int x){ sta[++top]=k,f[k]=max(f[k],x); } void selt(int x,int dep,int sum){ sel(sum,dep); for(auto &amp;it:e[x]) selt(it.to,dep+1,sum^1&lt;&lt;it.v); } void addt(int x,int dep,int sum){ add(sum,dep); for(auto &amp;it:e[x]) addt(it.to,dep+1,sum^1&lt;&lt;it.v); } void dfs(int x=1,int dep=1,int sum=0) { for(auto &amp;it:e[x]) if(it.to!=son[x]) dfs(it.to,dep+1,sum^1&lt;&lt;it.v),init(),ans[x]=max(ans[x],ans[it.to]);; if(son[x]) dfs(son[x],dep+1,sum^1&lt;&lt;sone[x]),ans[x]=max(ans[x],ans[son[x]]),res=0; for(auto &amp;it:e[x]) if(it.to!=son[x]) selt(it.to,dep+1,sum^1&lt;&lt;it.v),addt(it.to,dep+1,sum^1&lt;&lt;it.v); add(sum,dep),sel(sum,dep),ans[x]=max(ans[x],res-2*dep); } 猫树 猫树：考虑对于线段树上的每个节点暴力记中点到左右端点的前缀和，那么对于一次询问只需要找到线段树上的 LCA\\text{LCA}LCA 进行一次合并，这样时间复杂度为 O(nlog⁡+q)O(n\\log+q)O(nlog+q)，空间复杂度为 O(nlog⁡)O(n\\log)O(nlog)，找 LCA\\text{LCA}LCA 需要将序列补为 2n2^n2n，LCA\\text{LCA}LCA 即为 l,r\\text l,\\text rl,r 编号的 LCP\\text{LCP}LCP，在猫树因为开空间的关系是每层节点共用一维空间，找到深度就行。 struct tree{ int pos[N],v[21][N],suf[21][N]; void build(int l=1,int r=1&lt;&lt;(__lg(n)+1),int now=1,int d=1) { if(l==r) return pos[l]=now,void(); int mid=(l+r)&gt;&gt;1,sum,mxsum; v[d][mid]=suf[d][mid]=mxsum=sum=a[mid]; for(rint i=mid-1;i&gt;=l;i--) { sum+=a[i],mxsum=max(a[i],mxsum+a[i]); v[d][i]=max(v[d][i+1],mxsum); suf[d][i]=max(suf[d][i+1],sum); } v[d][mid+1]=suf[d][mid+1]=mxsum=sum=a[mid+1]; for(rint i=mid+2;i&lt;=r;i++) { sum+=a[i],mxsum=max(a[i],mxsum+a[i]); v[d][i]=max(v[d][i-1],mxsum); suf[d][i]=max(suf[d][i-1],sum); } build(l,mid,now&lt;&lt;1,d+1),build(mid+1,r,now&lt;&lt;1|1,d+1); } int ask(int l,int r) { if(l==r) return a[l]; int d=__lg(pos[l])-__lg(pos[l]^pos[r]); return max({v[d][l],v[d][r],suf[d][l]+suf[d][r]}); } }t; 猫树分治：空间开不下时，可以离线询问然后分治解决，时间复杂度不变。 struct tree{ int f[N][210]; void init(int l=1,int r=1&lt;&lt;(__lg(n)+1),int now=1) { if(l==r) return pos[l]=now,void(); int mid=(l+r)&gt;&gt;1; init(l,mid,now&lt;&lt;1),init(mid+1,r,now&lt;&lt;1|1); } void work(int l=1,int r=1&lt;&lt;(__lg(n)+1),int now=1) { if(l==r) return; int mid=(l+r)&gt;&gt;1,rr=min(r,n); for(rint i=0;i&lt;=200;i++) f[mid][i]=f[mid+1][i]=0; for(rint i=200;i&gt;=w[mid];i--) f[mid][i]=v[mid]; for(rint i=mid-1;i&gt;=l;i--) { for(rint j=0;j&lt;=200;j++) f[i][j]=f[i+1][j]; for(rint j=200;j&gt;=w[i];j--) f[i][j]=max(f[i][j],f[i][j-w[i]]+v[i]); } for(rint i=200;i&gt;=w[mid+1];i--) f[mid+1][i]=v[mid+1]; for(rint i=mid+2;i&lt;=rr;i++) { for(rint j=0;j&lt;=200;j++) f[i][j]=f[i-1][j]; for(rint j=200;j&gt;=w[i];j--) f[i][j]=max(f[i][j],f[i][j-w[i]]+v[i]); } for(auto &amp;it:q[now]) for(rint i=0;i&lt;=it.x;i++) ans[it.id]=max(ans[it.id],f[it.l][i]+f[it.r][it.x-i]); work(l,mid,now&lt;&lt;1),work(mid+1,r,now&lt;&lt;1|1); } void ask(int l,int r,int x,int i) { if(l==r) ans[i]=(w[l]&lt;=x?v[l]:0); else q[pos[l]&gt;&gt;(__lg(pos[l]^pos[r])+1)].push_back({l,r,x,i}); } }t; 带状高消 一个矩阵所有有值的位置距离主对角线 ≤d\\le d≤d 称为带状矩阵，消元可以做到 O(nd2)O(nd^2)O(nd2) 的复杂度。具体地，考虑高斯消元时内层消元时只考虑周围 d2d^2d2 的有值的区域，在找主元系数为 000 时交换列仍然不会破坏带状的性质，也可以交换行向量，这样横向的 ddd 可能变为 2d2d2d，带 222 倍常数。 void gauss() { const int d=3; for(rint i=1;i&lt;=m;i++) { if(!a[i][i]) for(rint j=i+1;j&lt;=min(i+d,m);j++) if(a[j][i]) { for(rint k=i;k&lt;=min(i+2*d,m);k++) swap(a[i][k],a[j][k]); swap(a[i][m+1],a[j][m+1]); break; } if(!a[i][i]) continue; for(rint j=i+1;j&lt;=min(i+d,m);j++) { int res=a[j][i]*qp(a[i][i])%p; for(rint k=i;k&lt;=min(i+2*d,m);k++) a[j][k]=(a[j][k]-a[i][k]*res%p+p)%p; a[j][m+1]=(a[j][m+1]-a[i][m+1]*res%p+p)%p; } } for(rint i=m;i;i--) { for(rint j=i+1;j&lt;=min(i+2*d,m);j++) a[i][m+1]=(a[i][m+1]-a[i][j]*a[j][m+1]%p+p)%p,a[i][j]=0; a[i][m+1]=a[i][m+1]*qp(a[i][i])%p,a[i][i]=1; } } 如果是一个带状矩阵加上一个三角矩阵，可以用类似的方法做到 O(n2d)O(n^2d)O(n2d)，此时就只能交换列不然会破坏性质。 void gauss() { const int d=3; for(rint i=1;i&lt;=n;i++) fr[i]=i; for(rint i=1;i&lt;=n;i++) { if(!a[i][i]) for(rint j=i+1;j&lt;=min(n,i+d);j++) if(a[j][i]) { for(rint k=1;k&lt;=n;k++) swap(a[k][i],a[k][j]); swap(fr[i],fr[j]); break; } if(!a[i][i]) continue; int inv=qp(a[i][i]); for(rint j=i+1;j&lt;=n;j++) { int res=inv*a[j][i]%p; for(rint k=i;k&lt;=min(n,i+d);k++) a[j][k]=(a[j][k]-a[i][k]*res%p+p)%p; a[j][n+1]=(a[j][n+1]-a[i][n+1]*res%p+p)%p; } } for(rint i=n;i;i--) { for(rint j=i+1;j&lt;=min(n,i+d);j++) a[i][n+1]=(a[i][n+1]-a[j][n+1]*a[i][j]%p+p)%p,a[i][j]=0; a[i][n+1]=a[i][n+1]*qp(a[i][i])%p,a[i][i]=1; ans[fr[i]]=a[i][n+1]; } }","categories":[],"tags":[{"name":"省选","slug":"省选","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/tags/省选/"}],"keywords":[]},{"title":"嘴巴开计算几何","slug":"嘴巴开计算几何","date":"2022-12-05T02:40:48.000Z","updated":"2023-03-04T15:57:25.813Z","comments":false,"path":"2022/12/05/嘴巴开计算几何/","link":"","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/2022/12/05/嘴巴开计算几何/","excerpt":"","text":"基础 点（向量）：看作 1×21\\times21×2 的矩阵，点积意为投影，叉积意为面积，正负按右手定则。 点排序：按 pair 排；线排序：按极角 atan2(y,x)atan2(y,x)atan2(y,x) 排，平行则上面排前面。 bool operator &lt;(Line &amp;a) { double x=angle(),y=a.angle(); if(abs(x-y)&lt;eps) return (v^(a.P-P))&lt;0; return x&lt;y; } 两线交点：平行则不交，端点出发按比例移动到交点，比例按叉积算面积比例来算。 Point inter(const Line &amp;a,const Line &amp;b) { if(abs(a.v^b.v)&lt;eps) return {7-p,p+9}; //not_inter return a.P+a.v*(((b.P-a.P)^b.v)/(a.v^b.v)); } 两线夹角：点积定义即可：a⋅b=∣a∣∣b∣cos⁡θa·b=|a||b|\\cos\\thetaa⋅b=∣a∣∣b∣cosθ 点/向量顺时针旋转：[xy]×[cos⁡θ−sin⁡θsin⁡θcos⁡θ]\\begin{bmatrix} x &amp; y \\end{bmatrix}\\times\\begin{bmatrix} \\cos\\theta &amp; -\\sin\\theta\\\\ \\sin\\theta &amp; \\cos\\theta \\end{bmatrix}[x​y​]×[cosθsinθ​−sinθcosθ​] 点到直线的距离：叉积算面积除以底；点到线段的距离：特判点，点积看是否在两端点外，规约到直线。 double point_to_seg(const Point &amp;x,const Point &amp;a,const Point &amp;b) { if(a==b) return (x-a).mo(); Vector v1=b-a,v2=x-a,v3=x-b; if(v1*v2&lt;0) return v2.mo(); if(v1*v3&gt;0) return v3.mo(); return point_to_line(x, a, b); } 点在直线上：与两端点连线叉积为 000 ；点在线段上：且内向连线点积 ≤0\\leq0≤0 . 凸包 求凸包：将点排序，依次往里加点同时维护凸性即可，正反做一遍，凸性用叉积判即可，平的就看是否新的更短即可，得到凸包逆时针序点集。 bool tu(const Point &amp;a,const Point &amp;b,const Point &amp;c) { double pos=(a-c)^(b-c); if(abs(pos)&gt;eps) return pos&lt;0; return (a-c).mo()&lt;(b-c).mo()+eps; } int n;Point P[N],h[N&lt;&lt;1];int tail; void hull() { sort(P+1,P+n+1); h[++tail]=P[1],h[++tail]=P[2]; for(rint i=3;i&lt;=n;h[++tail]=P[i],i++) while(tail&gt;1&amp;&amp;!tu(P[i],h[tail],h[tail-1])) tail--; h[++tail]=P[n-1]; for(rint i=n-2;i;h[++tail]=P[i],i--) while(tail&gt;1&amp;&amp;!tu(P[i],h[tail],h[tail-1])) tail--; //h[tail]==h[1] } 旋转卡壳：求凸包直径，发现具有单调性和单峰性，枚举边同时单指针跟着走即可，用叉积判距离即可。 double hull_len() { if(tail&lt;=3) return (h[1]-h[tail-1]).mo(); double ans=0; for(rint i=1,j=3;i&lt;tail;i++) { while(((h[i+1]-h[i])^(h[j]-h[i]))&lt;((h[i+1]-h[i])^(h[j+1]-h[i]))) j=(j==tail-1?1:j+1); ans=max(ans,max((h[j]-h[i]).mo(),(h[j]-h[i+1]).mo())); } return ans; } 闵可夫斯基和：求两凸包点集之和形成的凸包，容易发现新凸包的边由原两凸包边组成，找到左下点然后一步步贪心加边即可。 int n,m,q,num1,num2; Point h1[N&lt;&lt;1],h2[N&lt;&lt;1],H[N&lt;&lt;2];int cnt; void minkfusji() { H[cnt=1]=h1[1]+h2[1]; int now1=1,now2=1; while(now1&lt;num1&amp;&amp;now2&lt;num2) { if(((h1[now1+1]-h1[now1])^(h2[now2+1]-h2[now2]))&gt;0) H[cnt+1]=H[cnt]+h1[now1+1]-h1[now1],now1++,cnt++; else H[cnt+1]=H[cnt]+h2[now2+1]-h2[now2],now2++,cnt++; } while(now1&lt;num1) H[cnt+1]=H[cnt]+h1[now1+1]-h1[now1],now1++,cnt++; while(now2&lt;num2) H[cnt+1]=H[cnt]+h2[now2+1]-h2[now2],now2++,cnt++; } 动态凸包：增量法，set 维护上下凸壳点集，势能分析复杂度是 O(nlog⁡)O(n\\log)O(nlog) ，二分找推平的区间端点即可。 三维凸包：考虑 O(n2)O(n^2)O(n2) 增量法，每次加点暴力枚举所有面看有没有被看到即可，要扰动点避免四点共面。 mt19937 rd(time(0)); struct Point{ double x,y,z; Point operator-(const Point &amp;a)const{return {x-a.x,y-a.y,z-a.z};} double operator*(const Point &amp;a)const{return x*a.x+y*a.y+z*a.z;} Point operator^(const Point &amp;a)const{return {y*a.z-z*a.y,z*a.x-x*a.z,x*a.y-y*a.x};} double mo(){return sqrt(x*x+y*y+z*z);} void shake(){x+=rd(),y+=rd(),z+=rd();} }P[N]; struct Plane{ int e[3]; Vector fa(){return (P[e[1]]-P[e[0]])^(P[e[2]]-P[e[0]]);} double area(){return fa().mo()/2;} bool above(const Point &amp;a){return (a-P[e[0]])*fa()&gt;=0;} }pl[N&lt;&lt;1],res[N&lt;&lt;1]; int n,m; bool use[N][N]; void hull() { pl[++m]={1,2,3},pl[++m]={3,2,1}; for(rint i=4;i&lt;=n;i++) { int cnt=0; for(rint j=1;j&lt;=m;j++) { bool in=pl[j].above(P[i]); if(!in) res[++cnt]=pl[j]; for(rint k=0;k&lt;3;k++) use[pl[j].e[k]][pl[j].e[(k+1)%3]]=in; } for(rint j=1;j&lt;=m;j++) for(rint k=0;k&lt;3;k++) { int x=pl[j].e[k],y=pl[j].e[(k+1)%3]; if(use[x][y]&amp;&amp;!use[y][x]) res[++cnt]={x,y,i}; } m=cnt; for(rint j=1;j&lt;=m;j++) pl[j]=res[j]; } } double hull_area() { hull(); double ans=0; for(rint i=1;i&lt;=m;i++) ans+=pl[i].area(); return ans; } 半平面交 求半平面交：将线排序，维护有效线的双端队列，依次往里加线，对于尾首维护交点在右，加完了再将尾首对起来维护，得到左半平面交，凸包点即为相邻两线交点，不封闭可以在外面框一层边界。 Line line[N];int n; int q[N],hh=1,tt; Point cut[N];int num; bool isright(const Line &amp;a,const Line &amp;b,const Line &amp;c) { Point P=inter(b,c); return (a.v^(P-a.P))&lt;-eps; } void halfcut() { sort(line+1,line+n+1); for(rint i=1;i&lt;=n;i++) { while(hh&lt;tt&amp;&amp;isright(line[i],line[q[tt]],line[q[tt-1]])) tt--; while(hh&lt;tt&amp;&amp;isright(line[i],line[q[hh]],line[q[hh+1]])) hh++; q[++tt]=i; } while(hh&lt;tt&amp;&amp;isright(line[q[hh]],line[q[tt]],line[q[tt-1]])) tt--; while(hh&lt;tt&amp;&amp;isright(line[q[tt]],line[q[hh]],line[q[hh+1]])) hh++; q[++tt]=q[hh]; for(rint i=hh;i&lt;tt;i++) cut[++num]=inter(line[q[i]],line[q[i+1]]); } 圆 三点定圆：即求外心，求两角平分线交点即可。 Circle get_circle(const Point &amp;a,const Point &amp;b,const Point &amp;c) { Line ab={(a+b)*0.5,rotate(b-a,Pi/2)}, bc={(b+c)*0.5,rotate(c-b,Pi/2)}; Point P=inter(ab,bc); return {P,dis(P,a)}; } 最小圆覆盖：随机增量法，每次加入的点若不在圆内则新圆必过该点，循环三层即可，将点集打乱后每次暴力重来复杂度是 O(n)O(n)O(n) . int n;Point P[N]; Circle min_circle() { mt19937 rd(time(0)); shuffle(P+1,P+n+1,rd); Circle c={P[1],0}; for(rint i=2;i&lt;=n;i++) if(dis(c.P,P[i])-c.r&gt;eps) { c={P[i],0}; for(rint j=1;j&lt;i;j++) if(dis(c.P,P[j])-c.r&gt;eps) { c={(P[i]+P[j])*0.5,dis(P[i],P[j])/2}; for(rint k=1;k&lt;j;k++) if(dis(c.P,P[k])-c.r&gt;eps) c=get_circle(P[i],P[j],P[k]); } } return c; } 圆反演： 圆内外的点一一映射，PPP 与 P′P&#x27;P′ 互为反演关系 ⇔\\Leftrightarrow⇔ ∣OP∣⋅∣OP′∣=R2|OP|·|OP&#x27;|=R^2∣OP∣⋅∣OP′∣=R2 且 OPP′OPP&#x27;OPP′ 共线。 不过反演圆心的圆反演后仍为圆，r′=12(1∣OA∣−r−1∣OA∣+r)R2r&#x27;=\\frac 1 2 (\\frac 1 {|OA|-r}-\\frac 1 {|OA|+r})R^2r′=21​(∣OA∣−r1​−∣OA∣+r1​)R2，过反演圆心的点反演后为两交点连成的直线。 两图形相切其对应的反演图形也相切。 应用：求过两圆外一点且与两圆相切的所有的圆。考虑以该点为反演圆心做圆反演，半径任意，那么符合条件的圆的反演为与两圆反演后的两圆的公切线，动手做点辅助线就可以推出来了。 复杂图形面积并 辛普森积分法：大致对于图形划分边界，对于每个边界内部用辛普森积分法计算，不断往下递归直到左半右半估算之和与总体估算误差很小，估算公式为 len×(f(l)+4f(mid)+f(r))/6len\\times(f(l)+4f(mid)+f(r))/6len×(f(l)+4f(mid)+f(r))/6 ，可以要求递归层数。 double f(double x) { //暴力计算横坐标x被覆盖的长度和 } double cal(double l,double r) { return (r-l)*(f(l)+4*f((r+l)/2)+f(r))/6; } double sim(double l,double r,double ans,double Eps=eps,int dep=1) { double mid=(l+r)/2,lans=cal(l,mid),rans=cal(mid,r); if(abs(lans+rans-ans)&lt;=15*Eps&amp;&amp;dep&lt;0) return lans+rans+(lans+rans-ans)/15; return sim(l,mid,lans,Eps/2,dep-1)+sim(mid,r,rans,Eps/2,dep-1); } double work() { double ans=0; for(rint i=1;i&lt;n;i++) ans+=sim(step[i],step[i+1],cal(step[i],step[i+1])); return ans; } 三角剖分 凸包：随便选一个点作为中心，把所有边作为底与该点连边就可以了。 任意多边形：若可以负面积则按凸包的做就可以了，否则 O(n2)O(n^2)O(n2) 每次暴力找一个凸角剖分递归下去，不会更优复杂度的做法。","categories":[],"tags":[{"name":"省选","slug":"省选","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/tags/省选/"}],"keywords":[]},{"title":"建站小记","slug":"建站小记","date":"2022-12-04T18:19:43.000Z","updated":"2023-03-07T14:38:43.003Z","comments":false,"path":"2022/12/05/建站小记/","link":"","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/2022/12/05/建站小记/","excerpt":"","text":"最後の祈りを的博客，今天，成立了！ \\鼓掌/\\欢呼/ 搭博客想法其实在刚学 OI 没多久就有了，当时看到辰星凌学姐搭得多么好，不过大概是有着完美主义的坏习惯的缘故，退役了也没搞出来。（大嘘） 总之博客跌跌撞撞地是搭好了，主题是用的小学时弄 pixiv 直翻别人博客时相中的 sakura 主题，穷哥们没有服务器所以换成了静态的 hexo 版本好跑在 github 上，当时注册 github 时还不知道什么是静态动态博客，傻乎乎地传了个 wordpress 的动态版本在 github 上乱搞，之后在发现了 hexo 版本的正确使用姿势就成功 copy 好了，不过发现没有什么好写的就丢在一边了。 之后到了令和的今天，洛谷上已经丢了几篇还算有意义的文，感觉是时候重启博客企划了，所以就找了有爱♂巢经验的同学简单学了下流程（在此鸟谢 zlxFTH学短 的指导），了解了下大概原理，跟着傻瓜式教学再次搭好了博客，不过很不符现在的审美，本着强迫症的理念不断改改改成了现在的模样，不过还没有完全竣工喵，吐槽一下到处找科技最后不如嗯堆 css，总之还是很有家的感觉呐诺哒！ 为之前的博文累死累活地适配了简介和图片，还是非常有成就感哒，但感觉自己的努力与之前想的改变世界的技术宅弗如远甚，到底是哪里出了问题呢？ 立一个多多写文的 flag，写完这篇，还有三篇，往后的人生也请多多指教啦！","categories":[],"tags":[{"name":"文记","slug":"文记","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/tags/文记/"}],"keywords":[]},{"title":"背包乱学","slug":"背包乱学","date":"2022-11-04T09:21:55.000Z","updated":"2023-03-04T15:58:19.154Z","comments":false,"path":"2022/11/04/背包乱学/","link":"","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/2022/11/04/背包乱学/","excerpt":"","text":"01背包 nnn 件物品带体积 cic_ici​ 价值 wiw_iwi​ ，选择若干个体积和 ≤V\\leq V≤V 的物品价值最大。 for(rint i=1;i&lt;=n;i++) for(rint j=all;j&gt;=c[i];j--) f[j]=max(f[j],f[j-c[i]]+w[i]); 时间 O(nV)O(nV)O(nV) ，空间 O(V)O(V)O(V) 。 完全背包 nnn 种物品带体积 cic_ici​ 价值 wiw_iwi​ 无限个，选择若干个体积和 ≤V\\leq V≤V 的物品价值最大。 for(rint i=1;i&lt;=n;i++) for(rint j=c[i];j&lt;=all;j++) f[j]=max(f[j],f[j-c[i]]+w[i]); 时间 O(nV)O(nV)O(nV) ，空间 O(V)O(V)O(V) 。 多重背包 nnn 种物品带体积 cic_ici​ 价值 wiw_iwi​ 有 numinum_inumi​ 个，选择若干个体积和 ≤V\\leq V≤V 的物品价值最大。 可以把数量二进制拆分后跑01背包，时间 O(V∑log⁡numi)O(V\\sum \\log num_i)O(V∑lognumi​) ，空间 O(V)O(V)O(V) 。 for(rint i=1;i&lt;=n;i++) { int cc=read(),ww=read(),num=read(); for(rint j=1;j&lt;num;j&lt;&lt;=1) num-=j,c[++nn]=cc*j,w[nn]=ww*j; c[++nn]=cc*num,w[nn]=ww*num; } 也可以对于每种物品通过枚举%体积的余数分开转移，利用单调队列优化转移，时间 O(nV)O(nV)O(nV)，空间 O(V)O(V )O(V) 。 for(rint i=1,ii=1;i&lt;=n;i++,ii^=1) { int c=read(),w=read(),num=read(); for(rint j=0;j&lt;c;j++) for(rint k=0,hh=0,tt=-1;j+k*c&lt;=all;k++) { while(hh&lt;=tt&amp;&amp;k-q[hh]&gt;num) hh++; if(hh&lt;=tt) f[ii][j+k*c]=max(f[!ii][j+k*c],f[!ii][j+q[hh]*c]+(k-q[hh])*w); else f[ii][j+k*c]=f[!ii][j+k*c]; while(hh&lt;=tt&amp;&amp;f[!ii][j+q[tt]*c]-q[tt]*w&lt;=f[!ii][j+k*c]-k*w) tt--; q[++tt]=k; } } 混合背包 就是背包有1、若干、无限个，按类型转移即可。 二维费用背包 多加一维即可。 bool 背包 例如求子集和之类的，bitset 优化，时空复杂度除 ω\\omegaω 。 分组背包 每组最多选一件物品，内层枚举组内即可。 树形背包 树上的背包，能否选择依赖树上的关系，朴素定义状态一般为 f[u][i]f[u][i]f[u][i] 表示 uuu 子树选 iii 个点的价值，朴素转移为 f[u][i+j]=∑f[u][i]×f[v][j]f[u][i+j]=\\sum f[u][i]\\times f[v][j]f[u][i+j]=∑f[u][i]×f[v][j] ，展开列项计算或是考虑每个点对只会在 LCA 贡献 O(1)O(1)O(1) 都可以得出 O(nk2)O(nk^2)O(nk2) 的复杂度，物品大小为1的话去掉不必要的转移则为 O(nk)O(nk)O(nk)。 树上选容量为 kkk 的带体积权值点且属于根连通块的最大权值和，朴素 O(nk2)O(nk^2)O(nk2) ，考虑对原树后序遍历后可以依次添加，f[i][j]=max(f[i−1][j−c[i]]+w[i],f[i−sz[i]][j])f[i][j]=max(f[i-1][j-c[i]]+w[i],f[i-sz[i]][j])f[i][j]=max(f[i−1][j−c[i]]+w[i],f[i−sz[i]][j]) ，省去了合并操作，就可以做到 O(nk)O(nk)O(nk) 。 树上选容量为 kkk 的带体积权值点且属于一个连通块的最大权值和，上述做法+点分治，根据主定理仍然 O(nk)O(nk)O(nk) 。 有 trick 是维护前后缀背包，可以快速计算排除某个节点不选的情况。 背包方案 具体方案和方案数都是先做一遍背包再倒过来搜。 总数量小的背包 O(2n/2)O(2^{n/2})O(2n/2) 折半搜索。 滚动前后缀背包 前缀背包显然可以滚动，滚动后缀背包考虑先求出总背包然后依次撤回，容易发现撤回其实就是倒着去掉物品的贡献。 总体积小的子集和 可以证明二进制拆分后物品总数量级别为 O(V)O(\\sqrt V)O(V​) ，然后跑01背包，时间 O(n+VV)O(n+V\\sqrt V)O(n+VV​) ，空间 O(n+C)O(n+C)O(n+C) 。 单体积小的背包 子集和 nnn 个 ≤D\\leq D≤D 的元素，求是否存在子集和为 CCC。 首先找到满足 ∑kwi≤C\\sum^k w_i\\leq C∑kwi​≤C 最大的 kkk ，把前面的取负，这样 C←C−∑kwi&lt;DC\\leftarrow C-\\sum^k w_i &lt; DC←C−∑kwi​&lt;D ，考虑定义 can(tot,l,r)can(tot,l,r)can(tot,l,r) 表示是否存在 λ∈{0,1}\\lambda \\in\\{0,1\\}λ∈{0,1} 使得 ∑i=1l−1wi+∑i=lrλiwi=tot\\sum_{i=1}^{l-1}w_i+\\sum^r_{i=l}\\lambda _iw_i=tot∑i=1l−1​wi​+∑i=lr​λi​wi​=tot ，发现固定 tot,rtot,rtot,r 则 can(tot,l,r)=1can(tot,l,r)=1can(tot,l,r)=1 的 lll 为一段前缀，同理固定 tot,ltot,ltot,l 则 can(tot,l,r)=1can(tot,l,r)=1can(tot,l,r)=1 的 rrr 为一段后缀，定义 f[tot][r]f[tot][r]f[tot][r] 表示满足 can(tot,l,r)=1can(tot,l,r)=1can(tot,l,r)=1 的最大的 lll ，显然有 f[tot][r]≤f[tot][r+1]f[tot][r]\\leq f[tot][r+1]f[tot][r]≤f[tot][r+1] ，考虑转移有 {f[tot+wr+1][r+1]←f[tot][r]f[tot][r+1]←f[tot][r]f[tot−wl][r]←l,l∈[f[tot][r−1],f[tot][r])\\left\\{\\begin{matrix}f[tot+w_{r+1}][r+1]\\leftarrow f[tot][r] &amp; &amp; \\\\ f[tot][r+1]\\leftarrow f[tot][r] &amp; &amp; \\\\ f[tot-w_l][r]\\leftarrow l,l\\in[f[tot][r-1],f[tot][r]) &amp; &amp; \\end{matrix}\\right. ⎩⎨⎧​f[tot+wr+1​][r+1]←f[tot][r]f[tot][r+1]←f[tot][r]f[tot−wl​][r]←l,l∈[f[tot][r−1],f[tot][r])​​​ 时间 O(nD)O(nD)O(nD) ，空间 O(n+D)O(n+D)O(n+D) 。 for(rint i=N-W+1;i&lt;=N;i++) dp[0][i]=0; for(rint i=N+1;i&lt;=N+W;i++) dp[0][i]=1; dp[0][N-C+sum]=st; for(int i=st;i&lt;=n;i++,ii^=1) { for(rint j=N-W+1;j&lt;=N+W;j++) dp[ii][j]=dp[ii^1][j]; for(rint j=N-W+1;j&lt;=N;j++) dp[ii][j+w[i]]=max(dp[ii][j+w[i]],dp[ii^1][j]); for(rint j=N+w[i];j&gt;N;j--) for(rint k=dp[ii][j]-1;k&gt;=dp[ii^1][j];k--) dp[ii][j-w[k]]=max(dp[ii][j-w[k]],k); } 随机打乱集合，期望过程中最值为 O(nD)O(\\sqrt nD)O(n​D) ，直接 bitset 暴力背包，时间 O(nnDω)O(\\frac {n\\sqrt nD} {\\omega})O(ωnn​D​) ，空间 O(n+nDω)O(n+\\frac {\\sqrt nD} {\\omega})O(n+ωn​D​) 。 凸函数 max 卷积 前置知识：凸函数 (max,+)(max,+)(max,+) 卷积，即求 ci=max(aj+bi−j)c_i=max(a_j+b_{i-j})ci​=max(aj​+bi−j​)，且 bbb 为凸函数 。记 cic_ici​ 在 bbb 的决策位置为 posipos_iposi​ ，那么有 posi−1≤posipos_{i-1}\\leq pos_iposi−1​≤posi​ ，可以分治做到 O(nlog⁡)O(n\\log)O(nlog) 。 01背包 物品体积 ≤D\\leq D≤D，容量为 CCC 。对于相同重量的物品，我们肯定将价值从大到小贪心取，图像为一个凸函数。因此我们将背包在模 CCC 意义下分别做 (max,+)(max,+)(max,+) 卷积即可，时间 O(nlog⁡+DClog⁡C)O(n\\log+DC\\log C)O(nlog+DClogC)，空间 O(n+C)O(n+C)O(n+C)。 完全背包 物品体积 ≤D\\leq D≤D，容量为 CCC 。注意到对于 i&gt;Di&gt;Di&gt;D，有 dpi=maxj+k=i(dpj+dpk)dp_i=max_{j+k=i}(dp_j+dp_k)dpi​=maxj+k=i​(dpj​+dpk​)，且如果 ∣j−k∣&gt;D|j−k|&gt;D∣j−k∣&gt;D，我们始终可以调整得到 ∣j−k∣≤D|j−k|≤D∣j−k∣≤D。 因此通过 [dpj−D/2,⋯,dpj+D/2][dp_{j−D/2},⋯,dp_{j+D/2}][dpj−D/2​,⋯,dpj+D/2​] 以及 [dpk−D/2,⋯,dpk+D/2][dp_{k−D/2},⋯,dp_{k+D/2}][dpk−D/2​,⋯,dpk+D/2​]，可以暴力卷积得到 dpj+kdp_{j+k}dpj+k​ 的值。 现在，假如我们知道了 [dpk−D,⋯,dpk+D][dp_{k−D},⋯,dp_{k+D}][dpk−D​,⋯,dpk+D​]，它卷自己可以得到 [dp2k−D,⋯,dp2k+D][dp_{2k−D},⋯,dp_{2k+D}][dp2k−D​,⋯,dp2k+D​]，因此采用倍增的形式可以快速计算出 [dpC−D,⋯,dpC][dp_{C−D},⋯,dp_C][dpC−D​,⋯,dpC​]，答案即为其中的最大值。 初始化的地方，暴力计算 [dp0,⋯,dp2D][dp_0,⋯,dp_{2D}][dp0​,⋯,dp2D​] 即可，时间 O(D2log⁡C)O(D^2\\log C)O(D2logC)，空间 O(n+D)O(n+D)O(n+D)。 Reference：背包，子集和以及 (max, +) 卷积在特殊情形下的求法 - wlzhouzhuan - 博客园","categories":[],"tags":[{"name":"noip","slug":"noip","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/tags/noip/"}],"keywords":[]},{"title":"CSP-S 2022 琐记","slug":"CSP-S 2022 琐记","date":"2022-10-29T18:37:10.000Z","updated":"2023-03-04T16:05:05.757Z","comments":false,"path":"2022/10/30/CSP-S 2022 琐记/","link":"","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/2022/10/30/CSP-S 2022 琐记/","excerpt":"","text":"不会写文，不过都最后一回了还是写一写，近期记忆力衰退严重不写可能就真忘了，争取写的不比去年烂，各种啥啥标点用词断句排序详略我都考虑不管了，反正我从来都没眼看自己写的东西。 day -100+ 继承到了第一部智能机 iPhoneXs，用着很舒服，考虑到我比较焦虑所以当时没啥正反馈。 受迫性被购置了一台笔记本，用着很舒服，考虑到我比较焦虑所以当时没啥正反馈。 总之新机装修还是good爽啊，反正我从小就喜欢这个，可能比较类似于收集癖之类的，感觉不用展开讲。 离开了北海来到了森萌找到了师傅，牛校出牛子，被小两年的牛子随意吊打，之前学的太自闭了，热闹点学起来还是很快乐的。 时间过得就是很快，发生的很多已经记不到了，我个人可能极度右倾，不会适应环境和社交之类的，操作就非常变形非常拉垮，只能劝自己看开点算了。 day -50+ 自然而然的发展了一些娱乐活动，可能需要稍微回想一下，摸了几手游戏还是很控制剂量的，vcb复活了去偷了手播放器，看了takagi3，Arcane，93589，C100，反正不谈琐碎的话，确实我人生的轨迹都是这些点缀的，现实确实没啥爱好不感兴趣，只能说还是要爱惜记忆力，已经开始记不住很多东西了，另外还看了很多很棒的应该也没必要列举了，还是不断有新元素，之前文化课的时候确实是精神营养不良，人都低俗了一截，现在境况还是非常不错的。 反正几天的暑假就这样过去了，尽力去做了些有意义的事情，至少现在我还记得到。 然后是疫情封控，操作就非常的迷惑，感觉就极其自闭，越打越烂越烂越自闭，印象上反正就是特别低谷，反正后面就烂到每天一两点过睡了，作息就一拓答辩，后面的生物钟也是乱到现在，反正就考虑不管了身体已经习惯了，应该也是加剧了头疼记忆力衰退，不过以前也是这个鬼样，因素还是很多的，可能还是考虑解决某些根源上的问题，不过确实要慢慢往前多调调了，道理还是很显然的，只能说尽量，因为我现在就在熬夜码这些字我也不晓得我为啥子要早睡为啥子不早睡。 还是尝试了很多以前没试过的东西，还是非常刺激的，不晓得好久以前留下的了，反正就是啥子都要去试一下，新事物的体验是绝无仅有的，有一种人类野性的美。 day -10+ 首先刨去一车没营养把把垫底的联考。 体育活动还是很好的，唤起了很多肌肉记忆，非常神奇的，应该也唤起了很多激素之类的，精神好了很多，我都一年多没上过体育课了，关于体育课纯粹好耍的记忆好像都停在了小学，可能是我本来就不喜欢正经竞技类体育运动的缘故。 想不起来有啥子可以写的了，社交感觉达到了正常人标准，可喜可贺可喜可贺。 day -7+ 回了北海，到了就鼻炎恶化以及某种眼部疾病，隔离两天摆了两天，吃了药可能有红茶效果九点钟就睡了，第二天人就正常了很多，看上去早睡可以解决大多数问题。 整了个模版补完计划，pr没多少，不过还是超过了期望，博客啥的考虑需求层次理论还是咕咕咕算了。 想板刷ACwing自己还是太拉了，考虑画大饼是人类通病。 回了北海机房看到一片狼藉，新一届的卫生安全学术都太拉垮了，虽然当时的我还在学搜索之类的，条件也没有现在这么好，但至少基本节操得有，现在回头看来学好确实需要一些重要的东西，我不认为他们会比我强，不过应该有个别正常人，考虑不管，北海确实是烂完了。 翻了翻教练搬过来的旧书，一车闻所未闻的远古oi教辅，看了下16年的wc白皮书，发现原来beats也是在北海讲的，真的是祖上荣光，难以想象是怎么烂得这么快的。 学了手NoiLinux和Arbiter的使用，感觉还是有必要开虚拟机。 打了csp2020和csp2021，随意300+，不是很理解以前的我在搞马，不过信心确实很重要的，实力弱不管，心态一定要好，考虑人类种。 day 1 昨天打了模版洗了澡陶冶了情操，早上起来又洗了个澡，执行的非常棒，就是中午润去西橙的时候家长安排紊乱拖了很多行李很乱很匆忙，大概内心想法和Sheldon是一样的。 总之到了西橙，还是有很多感慨不过要考试所以考虑不管，进去了之后感觉比去年随意了很多，少了很多新鲜感，发现了今年北海人还是比较多，然后听到了有佬在弹钢琴，下意识听成了ab的曲，吓了一跳，然后发现不是。 上楼进了考场，操作比去年自然熟练了不少，终于像个正常人了，发现旁边的同学在敲键盘，于是我也开敲，调了下Dev设置敲完缺省源，尝试打开虚拟机，发现有密码，我不知道密码，可能是因为省选的阴影没有问监考老师，试密码试到开考也没试出来，给自己定的预期目标是一定要300+。 下发了压缩包，题目名字都比较高级，没有bracket这种毒瘤名字其实也不慌。 慢慢仔细的读完了T1，题意很清晰，所以就尝试去切，胡乱想了很多，还是没有什么好的思路，期望0.5h切掉结果40min还没好的思路，不过这次心态比较稳，于是冷静的去读了T2，感觉一眼秒了又看了一遍，确认切了准备去看T3，发现题目比较长准备之后再来读，于是开码T2线段树，大概10min多写完，但是样例挂了又很难手玩，于是下决心写了个对拍，然后手玩改改改，大概花了30min顺利切掉。 回头想T1又绕了一些弯路，忽然就提醒了自己一下这是T1，过了一下往年的难度于是开始换弱智思路，发现自己确实被诈骗了就快速码了个mx123，样例很水一下就过了，这个时候总时间过去了大概1h40min。 开始读T3，非常顺利地读完了，感觉暴力随便写但是正解没有好的思路，于是去看T4，T4题意很清晰不过有种T1的既视感，想了个假暴力做法但是跟T4难度不服，觉得自己肯定假但是很好写，于是先码再说，码完发现过不了样例观察出了假点，dfs改成bfs暴力就写好了。 准备回头写T3，算了算自己毛估估300，已经达到预期，于是对拍T1求稳，很顺利地拍完了，这时大概还剩1.5h，准备开始写T3暴力，我还没想好怎么判定于是先写完操作，写完发现判定很简单，于是稍微改了下顺利过了样例。 回头看T4，暴力档很多，不过看到特殊性质分很多于是不管k=1和k=2去想特殊性质，发现很简单于是开写，锅了就手玩样例慢慢调出来了，中途还去T3随意写了写两个10分的部分，随便加了个卡时，也没有打算正经拿分，调T4最后花了挺多时间，大概在结束前10min调出来了，反复瞪了几遍四道题没有发现问题就准备交卷了。 考完才发现自己一口水都没喝也没上厕所，也没有注意到有人去上厕所，意识到今天发挥很正常，潜意识惋惜了下去年的自己。 出了西橙校门发现天都黑完了啥也看不清，然后就光速坐上营养快线了。 估分：100+100+50+68=318 CCF：100+100+95+68=363 day2 凌晨确实是day2，写了这篇文章，完结撒花花。 Tenshi","categories":[],"tags":[{"name":"文记","slug":"文记","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/tags/文记/"}],"keywords":[]},{"title":"NOIP 数学简结","slug":"NOIP 数学简结","date":"2022-09-23T02:31:59.000Z","updated":"2023-03-07T14:38:05.454Z","comments":false,"path":"2022/09/23/NOIP 数学简结/","link":"","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/2022/09/23/NOIP 数学简结/","excerpt":"","text":"素数和约数 素数判定 O(n)O(\\sqrt n)O(n​)：枚举≤n\\leq \\sqrt n≤n​的数看是否能整除。 O(klog⁡n)O(k\\log n)O(klogn)：Miller-Rabin算法，k一般取10，最好取前12个质数LL内稳定判素. bool Miller_Rabin(int x) { if(x&lt;3||!(x&amp;1)) return x==2; int a=x-1,b=0; while(!(a&amp;1)) a&gt;&gt;=1,b++; int k=10; while(k--) { __int128 y=qp(rd()%(x-2)+2,a,x); if(y==1) continue; bool can=0; for(rint i=1;i&lt;=b;i++) { if(y==x-1) {can=1;break;} y=y*y%x; } if(!can) return 0; } return 1; } 筛法 O(nlog⁡log⁡)O(n\\log\\log)O(nloglog)：埃氏筛，枚举素数倍数，注意剪枝。 void ishai(int n) { susu[++tot]=2; for(rint i=3;i&lt;=x;i+=2) if(!use[i]) { susu[++tot]=i; for(rint j=i*i;j&lt;=x;j+=2*i) use[j]=1; } } ​ O(n)O(n)O(n)：欧拉筛，利用是否为素数为积性函数来筛，还可以在此过程中记录每个数的一个素因子做到 O(log⁡)O(\\log)O(log) 分解质因数，对于筛积性函数需要定义 f(p)f(p)f(p) 和 f(pk)f(p^k)f(pk) ，并且记录 lowilow_ilowi​ 表示 iii 的最小素因项。 void oshai(int n) { for(rint i=2;i&lt;=n;i++) { if(!use[i]) susu[++tot]=i; for(rint j=1;j&lt;=tot&amp;&amp;i*susu[j]&lt;=n;j++) { use[i*susu[j]]=1; if(!(i%susu[j])) break; } } } void ex_oshai(int n) { f[1]=low[1]1; for(rint i=2;i&lt;=n;i++) { if(!use[i]) susu[++tot]=i,f[i]=f_p,low[i]=i; for(rint j=1;j&lt;=tot&amp;&amp;i*susu[j]&lt;=n;j++) { use[i*susu[j]]=1; if(!(i%susu[j])) { low[i*susu[j]]=low[i]*susu[j]; if(low[i]==i) f[i*susu[j]]=f_p_k; else f[i*susu[j]]=f[i/low[i]]*f[low[i]*susu[j]]; break; } low[i*susu[j]]=susu[j]; f[i*susu[j]]=f[i]*f[susu[j]]; } } } 数论分块 利用 ⌊ni⌋\\left \\lfloor \\frac{n}{i} \\right \\rfloor⌊in​⌋ 只有n\\sqrt nn​种取值，相同取值的一起计算即可，r=n/n/lr=n/n/lr=n/n/l，k维数论分块是 O(kn)O(k\\sqrt n)O(kn​) 的。 最大公约数 具有可并性，可以用st表/线段树维护。 不断添数的话，总体的 gcd⁡\\gcdgcd 只会变化 log⁡\\loglog 次。 可以拆位，转化为对各质因数的幂次取min，lcm同理。 同余 裴蜀定理 ax+by=gcd⁡(a,b)ax+by=\\gcd(a,b)ax+by=gcd(a,b)必有一组整数解 (x,y)(x,y)(x,y)，可以拓展到多个的情况。 进一步结论：满足 ax+by=n(x,y,a,b∈N)ax+by=n(x,y,a,b\\in N)ax+by=n(x,y,a,b∈N) 有解的 nnn 任意一对满足 ni+nj≠a∗b−a−bn_i+n_j\\ne a*b-a-bni​+nj​=a∗b−a−b. 同余方程 扩欧可求 ax+by=gcd⁡(a,b)ax+by=\\gcd(a,b)ax+by=gcd(a,b) 的一组可行解，一解可得任意解，由此可求同余方程 ax≡1(modb)ax\\equiv 1\\pmod bax≡1(modb) 解。 void exgcd(int a,int b,int &amp;x,int &amp;y) { if(!b) return x=1,y=0,void(); exgcd(b,a%b,x,y); swap(x,y),y=y-(a/b)*x; } 扩展欧拉定理 ab≡{ab%φ(p)gcd⁡(a,p)=1abgcd⁡(a,p)≠1,b&lt;φ(p)ab%φ(p)+φ(p)gcd⁡(a,p)≠1,b≥φ(p)(modp)\\begin{equation} a^b\\equiv \\begin{cases} a^{b\\% \\varphi(p)}&amp;\\gcd(a,p)=1\\\\ a^b&amp;\\gcd(a,p)\\neq 1,b&lt;\\varphi(p)\\\\ a^{b\\%\\varphi(p)+\\varphi(p)}&amp;\\gcd(a,p)\\neq 1,b\\geq\\varphi(p) \\end{cases} \\pmod p \\end{equation} ab≡⎩⎨⎧​ab%φ(p)abab%φ(p)+φ(p)​gcd(a,p)=1gcd(a,p)=1,b&lt;φ(p)gcd(a,p)=1,b≥φ(p)​(modp)​​ 费马小定理 对于 p∈prime&amp;gcd⁡(a,p)=1p\\in prime\\&amp;\\gcd(a,p)=1p∈prime&amp;gcd(a,p)=1，有 ap−1=1a^{p-1}=1ap−1=1 . 可用于求解逆元。 威尔逊定理 ppp 为素数 ⇔\\Leftrightarrow⇔ (p−1)!≡−1(modp)(p-1)!\\equiv -1\\pmod p(p−1)!≡−1(modp). 乘法逆元 O(log⁡)O(\\log)O(log) 快速幂，适用于满足费马小定理的情况. O(log⁡)O(\\log)O(log) 扩欧，即求解同余方程 ax≡1(modp)ax\\equiv1\\pmod pax≡1(modp)，gcd⁡(a,p)≠1\\gcd(a,p)\\ne 1gcd(a,p)=1 时无解。 O(n)−O(1)O(n)-O(1)O(n)−O(1) 预处理。 inv[1]=1; for(rint i=2;i&lt;=n;i++) inv[i]=(p-p/i)*inv[p%i]%p; 扩展中国剩余定理 求解模线性同余方程组 {x≡b1 (mod a1)x≡b2 (mod a2)...x≡bn (mod an)\\begin{cases} x \\equiv b_1\\ ({\\rm mod}\\ a_1) \\\\ x\\equiv b_2\\ ({\\rm mod}\\ a_2) \\\\ ... \\\\ x \\equiv b_n\\ ({\\rm mod}\\ a_n)\\end{cases}⎩⎨⎧​x≡b1​ (mod a1​)x≡b2​ (mod a2​)...x≡bn​ (mod an​)​ 考虑如何将两方程合并为一个，考虑将 xxx 写成两个含待定系数方程的形式，则可列等式，发现是一个不定方程的形式，先用裴蜀定理判无解，再用扩欧求一组特解，回代求出一个特定的 xxx ，那么新的 a=lcm(a1,a2),b=x%aa=lcm(a_1,a_2),b=x\\%aa=lcm(a1​,a2​),b=x%a . 组合数学 二项式定理 (a+b)n=∑(ni)aibn−i(a+b)^n=\\sum \\binom n i a^ib^{n-i}(a+b)n=∑(in​)aibn−i , (∑txi)n=∑(nn1,n2,...,nt)∏txini(\\sum^t x_i)^n=\\sum \\binom n {n_1,n_2,...,n_t} \\prod^t x_i^{n_i}(∑txi​)n=∑(n1​,n2​,...,nt​n​)∏txini​​ 多重排列组合 多重集排列数=多重组合数= (nn1,n2,...,nt)\\binom n {n_1,n_2,...,n_t}(n1​,n2​,...,nt​n​) = n∏tni!\\frac n {\\prod^t n_i!}∏tni​!n​ 多重集组合数：若选择数&lt;=最小数量，则问题等价于 ∑kxi=r\\sum^k x_i=r∑kxi​=r 的非负整数解数目，插板法可得 ans=(r+k−1k−1)ans=\\binom {r+k-1} {k-1}ans=(k−1r+k−1​) . 否则考虑容斥原理枚举哪些数选完，ans=∑p=0k(−1)p∑∣A∣=p(k+r−1−p−∑nAik−1)ans=\\sum _{p=0}^k(-1)^p\\sum_{|A|=p} \\binom {k+r-1-p-\\sum n_{A_i}} {k-1}ans=∑p=0k​(−1)p∑∣A∣=p​(k−1k+r−1−p−∑nAi​​​) 不相邻组合 nnn 个相同物品选 kkk 个不相邻的= (n−k+1k)\\binom {n-k+1} k(kn−k+1​) ，理解为在 n−kn-kn−k 个数里插 kkk 个不相邻的隔板。 圆排列 (n−1)!(n-1)!(n−1)! ，考虑任何一种普通排列都有n种等价圆排列。 错排 Dn=(n−1)(Dn−1+Dn−2)=nDn−1+(−1)n=n!∑(−1)ii!D_n=(n-1)(D_{n-1}+D_{n-2})=nD_{n-1}+(-1)^n=n!\\sum \\frac {(-1)^i} {i!}Dn​=(n−1)(Dn−1​+Dn−2​)=nDn−1​+(−1)n=n!∑i!(−1)i​ 组合恒等式 比例公式 (nk)=nk(n−1k−1)\\binom n k=\\frac n k \\binom {n-1} {k-1} (kn​)=kn​(k−1n−1​) 二项式定理特例 ∑(−1)i(ni)=[n=0]\\sum (-1)^i\\binom n i=[n=0] ∑(−1)i(in​)=[n=0] 范德蒙德卷积 ∑(ni)(mm−i)=(m+nm)\\sum \\binom n i \\binom m {m-i}=\\binom {m+n} m ∑(in​)(m−im​)=(mm+n​) 范德蒙德卷积特例(n=m) ∑(ni)2=(2nn)\\sum \\binom n i ^2=\\binom {2n} n ∑(in​)2=(n2n​) 组合数带权和 ∑i(ni)=n2n−1\\sum i\\binom n i=n2^{n-1} ∑i(in​)=n2n−1 对消公式 (nm)(mk)=(nk)(n−km−k)\\binom n m\\binom m k=\\binom n k\\binom {n-k} {m-k} (mn​)(km​)=(kn​)(m−kn−k​) 自卷公式 ∑(n−ii)=Fibn+1\\sum \\binom {n-i} i=Fib_{n+1} ∑(in−i​)=Fibn+1​ 吸收公式 (nk)k=(n−1k−1)n\\binom n k k=\\binom {n-1} {k-1} n (kn​)k=(k−1n−1​)n (nk)(n−k)=(n−1k)n\\binom n k (n-k)=\\binom {n-1} k n (kn​)(n−k)=(kn−1​)n 平行求和 ∑k(n+ii)=(n+k+1k)\\sum^k \\binom {n+i} i=\\binom {n+k+1} k ∑k​(in+i​)=(kn+k+1​) 上指标求和 ∑n(ik)=(n+1k+1)\\sum^n \\binom i k=\\binom {n+1} {k+1} ∑n​(ki​)=(k+1n+1​) 下指标差求和 ∑k(ni)(−1)i=(−1)k(n−1k)\\sum ^k \\binom n i (-1)^i=(-1)^k\\binom {n-1} k ∑k​(in​)(−1)i=(−1)k(kn−1​) Lucas定理 (nm)≡(n/pm/p)×(n%pm%p)(modp)\\binom n m\\equiv \\binom {n/p} {m/p} \\times \\binom {n\\%p} {m\\%p} \\pmod p (mn​)≡(m/pn/p​)×(m%pn%p​)(modp) 卡特兰数 Hn=∑Hi−1Hn−i=Hn−1(4n−2)n+1=(2nn)n+1=(2nn)−(2nn−1)H_n=\\sum H_{i-1}H_{n-i}=\\frac {H_{n-1}(4n-2)} {n+1}=\\frac {\\binom {2n} n} {n+1}=\\binom {2n} n -\\binom {2n} {n-1} Hn​=∑Hi−1​Hn−i​=n+1Hn−1​(4n−2)​=n+1(n2n​)​=(n2n​)−(n−12n​) ​ 含义：① nnn 个 111 和 nnn 个 −1-1−1 排列使得无负前缀的方案数、② n×nn\\times nn×n 网格从左下到右上且不穿对角线的非降路径数、③ 圆上 2n2n2n 个点划 nnn 条线段不交的方案数、④ n+2n+2n+2 个点的凸多边形三角剖分方案数、⑤ 长为 nnn 的出栈序列数量、⑥ nnn 个点的二叉树形态数。 斯特林数 第二类斯特林数： {nk}{n \\brace k}{kn​} 即 S(n,k)S(n,k)S(n,k) ，表示将 nnn 个数分为 kkk 个非空集合的方案数. {nk}={n−1k−1}+k{n−1k}=∑m(−1)m−iini!(m−i)!{n \\brace k}={n-1 \\brace k-1}+k{n-1 \\brace k}=\\sum^m \\frac {(-1)^{m-i}i^n} {i!(m-i)!} {kn​}={k−1n−1​}+k{kn−1​}=∑m​i!(m−i)!(−1)m−iin​ 第一类斯特林数： [nk]{n \\brack k}[kn​] ，表示将 nnn 个数分为 kkk 个圆排列的方案数。 [nk]=[n−1k−1]+(n−1)[n−1k]{n \\brack k}={n-1 \\brack k-1}+(n-1){n-1 \\brack k} [kn​]=[k−1n−1​]+(n−1)[kn−1​] 十二重计数法 球不同盒不同：mnm^nmn、 球不同盒不同无空：∑m(−1)i(mi)(m−i)n\\sum^m (-1)^i\\binom m i (m-i)^n∑m(−1)i(im​)(m−i)n （容斥） 球不同盒同：∑m{ni}\\sum^m {n \\brace i}∑m{in​} 球不同盒同无空：{nm}{n \\brace m}{mn​} 球同盒不同：(n+m−1m−1)\\binom {n+m-1} {m-1}(m−1n+m−1​) 球同盒不同非空：(n−1m−1)\\binom {n-1} {m-1}(m−1n−1​) 球同盒同：DP，Fn,m=Fn−m,m+Fn,m−1F_{n,m}=F_{n-m,m}+F_{n,m-1}Fn,m​=Fn−m,m​+Fn,m−1​，考虑全部+1或添0即可 球同盒同非空：Fn−m,mF_{n-m,m}Fn−m,m​ 线性代数 矩阵乘法 具有结合律没有交换律，可以做快速幂，可以循环展开优化常数。 加速递推、作为表达修改的tag 定长路径统计：定长路径数量即做k次邻接矩阵的矩乘，定长最短路即做k次邻接矩阵的floyd，若统计的是 ≤\\leq≤ 加上自环即可。 高斯消元 逐步消成对角矩阵即可，当前元要找所在列中系数绝对值最大的一行，然后对其他行消除该元即可。 解n元一次方程组，答案即为第n+1列。 计算行列式：交换两行时答案取反，最终答案即为对角上的数乘积。 求逆矩阵：在原矩阵右边拼上一个单位矩阵，把左边消成单位矩阵右边就是逆矩阵了，消不出来则无解。 异或方程组：解法同理。 线性基 一般指异或线性基，维护数集的异或集合(不含0，如要统计则考虑e[0]后记录是否出现0，没有被选进线性基的数可等价看作为0)，可以贪心构造，维护点对的异或集合是01trie。 void insert(int x) { for(rint i=50;~i;i--) if(x&gt;&gt;i&amp;1) { if(!e[i]) {e[i]=x;break;} x^=e[i]; } } 异或线性基的大小只有 log⁡V\\log VlogV，合并只能逐个插入是 O(log⁡2)O(\\log ^2)O(log2) 的，区间线性基可以用前缀线性基来贪心维护，额外维护时间信息，相异或时swap留下时间更大的一项即可。 实数线性基：考虑异或线性基的01改成了实数，性质是相同的，复杂度会高一维。","categories":[],"tags":[{"name":"noip","slug":"noip","permalink":"https://jsdelivr.codeqihan.com/gh/saigonoinorio/saigonoinorio.github.io@1.1/tags/noip/"}],"keywords":[]}]}